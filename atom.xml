<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Snail-z Notes</title>
  <subtitle>书山有路勤为径，学海无涯苦作舟</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://note.snail-z.me/"/>
  <updated>2017-05-14T09:29:43.000Z</updated>
  <id>http://note.snail-z.me/</id>
  
  <author>
    <name>Snail-z</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS面试技术问题总结</title>
    <link href="http://note.snail-z.me/2017/05/13/iOS%E9%9D%A2%E8%AF%95%E6%8A%80%E6%9C%AF%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://note.snail-z.me/2017/05/13/iOS面试技术问题总结/</id>
    <published>2017-05-13T08:36:32.000Z</published>
    <updated>2017-05-14T09:29:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下自己最近面试过程中遇到的一些面试题。</p>
<h4 id="1-OC中-property的作用是什么？可以有哪些关键字修饰？"><a href="#1-OC中-property的作用是什么？可以有哪些关键字修饰？" class="headerlink" title="1. OC中@property的作用是什么？可以有哪些关键字修饰？"></a>1. OC中@property的作用是什么？可以有哪些关键字修饰？</h4><p>@Property是声明属性的语法，作为OC的一项特性，主要作用就在于封装对象中的数据。可以快速方便的为实例变量创建存取器，并允许通过点语法使用存取器。<br>@property本质就是ivar(实例变量) 和 getter / setter(存取方法)。</p>
<blockquote>
<p>存取器（accessor）：用于获取和设置实例变量的方法。用于获取实例变量值的存取器是getter，用于设置实例变量值的存取器是setter。</p>
</blockquote>
<p>关键字修饰：</p>
<ul>
<li>线程安全的(关于是否原子访问): <code>atomic, nonatomic</code> </li>
<li>访问权限的(关于访问控制操作): <code>readonly, readwrite</code></li>
<li>内存管理(MRC)(关于set方法中属性引用计数相关): <code>assign, retain, copy</code></li>
<li>内存管理(ARC)(增加了weak、strong属性): <code>assign, strong, weak, copy</code></li>
<li>指定方法名称: <code>getter=  / setter=</code><a id="more"></a>
</li>
</ul>
<h4 id="2-ARC下，不显示指定任何属性关键字时，默认的关键字都有哪些？"><a href="#2-ARC下，不显示指定任何属性关键字时，默认的关键字都有哪些？" class="headerlink" title="2. ARC下，不显示指定任何属性关键字时，默认的关键字都有哪些？"></a>2. ARC下，不显示指定任何属性关键字时，默认的关键字都有哪些？</h4><ul>
<li>基本数据类型默认关键字是<code>atomic, readwrite, assign</code></li>
<li>普通的OC对象默认关键字是<code>atomic, readwrite, strong</code></li>
</ul>
<h4 id="3-谈谈对-protocol的理解？-property能否在-protocol中使用？"><a href="#3-谈谈对-protocol的理解？-property能否在-protocol中使用？" class="headerlink" title="3. 谈谈对@protocol的理解？@property能否在@protocol中使用？"></a>3. 谈谈对@protocol的理解？@property能否在@protocol中使用？</h4><p>协议声明了任何类都能够选择实现的程序接口。协议能够使两个不同继承树上的类相互交流并完成特定的目的，因此它提供了除继承外的另一种选择。如果协议遵守者实现了协议中的方法，那么声明协议的类就能够通过遵守者调用协议中的方法。<br>总结:</p>
<ul>
<li>@Protocol是用来声明一系列方法定义公共接口(不能声明成员变量)，不能写实现</li>
<li>只要某个类遵守了这个协议，就拥有了这个协议中的所有方法声明</li>
<li>只要父类遵守了某个协议，那么它的子类也遵守</li>
<li>OC不能多继承但是能够遵守多个协议；继承<code>:</code>  遵守协议<code>&lt;&gt;</code></li>
<li>基协议:<code>&lt;NSObject&gt;</code>基协议，是最基本的协议其中声明了很多最基本的方法，例如要辨别id &lt;协议名&gt;这个指针所指的对象属于哪个类，就要用到<code>-isMemberOf:</code>这个方法，而这个方法是<code>&lt;NSObject&gt;</code>这个协议中的方法之一，所以我们自定义的协议都需要继承<code>&lt;NSObject&gt;</code>。</li>
<li>协议可以遵守协议，一个协议遵守了另一个协议，就可以拥有另一个协议中的方法声明(称为协议继承)</li>
</ul>
<blockquote>
<p>协议中能够声明方法，以及属性。但是不能定义实例变量。@property包含了实例变量、setter方法和getter方法。在类中定义的属性，当然三者都有，然而由于@protocol特性的限制，@property在@protocol中并不会合成实例变量，只会合成存取方法。这就要求该协议的遵守者必须自己写出setter和getter方法的实现。但是有一种情况是不需要的，那就是遵守者本来就有这个属性，此时系统会为这个属性自动生成存取方法，既然已经实现了，那么遵守者就没必要去实现协议中的这个属性了。尽管可以实现‘伪属性’，但是，我们还是应该尽量把属性定义在主接口中，而不应该定义在协议中。</p>
</blockquote>
<h4 id="4-通过Category给现有类添加的属性，可以直接使用吗？"><a href="#4-通过Category给现有类添加的属性，可以直接使用吗？" class="headerlink" title="4. 通过Category给现有类添加的属性，可以直接使用吗？"></a>4. 通过Category给现有类添加的属性，可以直接使用吗？</h4><p>比如建立个UIView的Loading分类并增加beginLoading属性，如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UIView</span> (<span class="title">Loading</span>)</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIView</span> *beginLoading;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p> 你会发现编译器并不会报任何错误，build一下也不会有问题，但是运行后会发生crash。这是因为在运行时找不到getter and setter methods，所以发生崩溃。如何解决？可以利用<code>runtime</code>的<a href="http://nshipster.com/associated-objects/" target="_blank" rel="external">Associated Objects</a>动态关联属性来解决问题。<br> 参考：<a href="http://www.cnblogs.com/Ohero/p/4739089.html" target="_blank" rel="external">iOS之Category属性的理解</a></p>
<ul>
<li>继续问：通过Associated关联的对象被存放在什么地方，关联对象的生命周期是什么样的？<br> 可以参考这篇文章：<a href="http://blog.leichunfeng.com/blog/2015/06/26/objective-c-associated-objects-implementation-principle/" target="_blank" rel="external">Objective-C Associated Objects 的实现原理</a></li>
</ul>
<h4 id="5-synthesize和-dynamic分别有什么作用？"><a href="#5-synthesize和-dynamic分别有什么作用？" class="headerlink" title="5. @synthesize和@dynamic分别有什么作用？"></a>5. @synthesize和@dynamic分别有什么作用？</h4><p><code>@synthesize</code>和<code>@dynamic</code>是@property的两个对应词。如果<code>@synthesize</code>和<code>@dynamic</code>都没写，那么默认的就是<code>@syntheszie var = _var;</code><br>@synthesize告诉编译器：如果你没有手动实现setter和getter方法，编译器会自动帮你生成。<br>@dynamic 告诉编译器：属性的setter与getter方法由用户自己实现，不自动生成。（当然对于readonly的属性只需提供getter即可）。假如一个属性被声明为<code>@dynamic var</code>，然后你没有提供@setter方法和@getter方法，编译的时候没问题，但是当程序运行到<code>instance.var = someVar</code>，由于缺setter方法会导致程序崩溃；或者当运行到<code>someVar = var</code>时，由于缺 getter 方法同样会导致崩溃。编译时没问题，运行时才执行相应的方法，这就是所谓的动态绑定。</p>
<h4 id="6-说一说ARC下的assign与weak区别？"><a href="#6-说一说ARC下的assign与weak区别？" class="headerlink" title="6. 说一说ARC下的assign与weak区别？"></a>6. 说一说ARC下的assign与weak区别？</h4><ul>
<li>weak :<br>1）ARC中，在有可能出现循环引用的时候，往往要通过让其中一端使用weak来解决，比如最常见的delegate代理属性。<br>2）如果自身已经对它进行一次强引用，没有必要再次强引用时也会使用weak。比如自定义IBOutlet控件属性一般使用weak，当然也可以使用strong。</li>
<li>assign :<br>assign是指针赋值，不对引用计数操作，适用于基本数据类型如<code>NSInteger, int, float, struct</code>等值类型，不适用于引用类型。</li>
<li>不同点：<br>weak，表明该属性定义了一种“非拥有关系” (nonowning relationship)。为属性设置新值时，设置方法既不保留新值，也不释放旧值。<br>assign也可以修饰对象，但是用assign修饰的对象在释放后，指针的地址还是存在的，也就是说指针并没有被置为nil，会造成众所周知的野指针异常。然而，assign修饰的基础数据类型(例如NSInteger等)和C数据类型(int, float, double, char)等一般分配在栈空间上，栈空间的内存会由系统自动处理，当分配的栈空间的内存没有被指针指向时就会被销毁，所以不会造成野指针异常。<br>weak比assign多了一个功能就是当属性所指向的对象消失的时候（也就是内存引用计数为0）会自动赋值为 nil，这样再向 weak修饰的属性发送消息就不会导致野指针操作crash。</li>
<li>总结：<br>assign 适用于基本数据类型如int,float,struct等值类型，不适用于引用类型。因为值类型会被放入栈中，遵循先进后出原则，由系统负责管理栈内存。而引用类型会被放入堆中，需要自己手动管理内存或通过ARC管理。<br>weak适用于delegate等引用类型，不会导致野指针问题，也不会循环引用，非常安全。</li>
</ul>
<h4 id="7-iOS中weak的实现原理"><a href="#7-iOS中weak的实现原理" class="headerlink" title="7. iOS中weak的实现原理?"></a>7. iOS中weak的实现原理?</h4><p> 参考文章：<a href="http://www.cocoachina.com/ios/20170328/18962.html" target="_blank" rel="external">iOS 底层解析weak的实现原理（包含weak对象的初始化，引用，释放的分析）</a></p>
<h4 id="8-NotificationCenter为什么要removeObserver-如何实现自动remove"><a href="#8-NotificationCenter为什么要removeObserver-如何实现自动remove" class="headerlink" title="8. NotificationCenter为什么要removeObserver? 如何实现自动remove?"></a>8. NotificationCenter为什么要removeObserver? 如何实现自动remove?</h4><p>首先NotificationCenter是一个单例类，通过<code>[NSNotificationCenter defaultCenter]</code>来获取单例对象。<br>它有三个核心函数和一个观察者数组：</p>
<ul>
<li>订阅消息： addObserver()。订阅感兴趣的消息。</li>
<li>发布消息： postNotification()。发布消息。</li>
<li>退订消息： removeObserver()。不感兴趣了，就退订。</li>
<li>观察者数组： _observers</li>
</ul>
<p>Notification是一个单例类，通常在释放场景或者某个对象之前，都要取消场景或对象订阅的消息，否则，注册通知的类被销毁以后再当消息产生时，会因为对象不存在，即向野指针发送了消息，而产生一些意外的BUG。<br>实现自动<code>remove:</code>通过自释放机制，通过动态属性将<code>remove</code>转移给第三者解除耦合，达到自动实现remove</p>
<h4 id="9-NSNotification、KVO、Delegate和Block的区别？"><a href="#9-NSNotification、KVO、Delegate和Block的区别？" class="headerlink" title="9. NSNotification、KVO、Delegate和Block的区别？"></a>9. NSNotification、KVO、Delegate和Block的区别？</h4><p>KVO就是cocoa框架实现的观察者模式，通过KVO可以监测一个值得变化，比如View的高度变化。是一对多的关系，一个值得变化会通知所有的观察者。一般使用场景是数据，需求是数据变化，比如股票价格变化，一般使用KVO（观察者模式）。<br>NSNotification是通知，也是一对多的使用场景。NSNotification的特点就是需要被观察者先主动发出通知，然后观察者注册监听后再来进行相应，比KVO多了发送通知的异步，但是其优点是监听不局限于属性的变化，还可以对多种多样的状态变化进行监听，监听范围广，使用也更灵活。<br>Notification一般是进行全局通知，是弱关联，消息发出后，不需要知道是谁发的也可以做出相应的反应，同理发消息的人也不需要知道接收的人也可以正常发出的消息。<br>Delegate是强关联，就是委托和代理双方互相知道，是一对一关系。<br>Block是delegate的另一种形式，是函数式编程的一种形式。使用场景跟delegate一样，相比delegate更灵活，而且比代理的实现更直观。</p>
<h4 id="10-UIViewController的生命周期及iOS程序执行顺序？"><a href="#10-UIViewController的生命周期及iOS程序执行顺序？" class="headerlink" title="10. UIViewController的生命周期及iOS程序执行顺序？"></a>10. UIViewController的生命周期及iOS程序执行顺序？</h4><p>UIViewController中与其生命周期有关的几个函数如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//类的初始化方法</span></div><div class="line">+ (<span class="keyword">void</span>)initialize;</div><div class="line"><span class="comment">//对象初始化方法</span></div><div class="line">- (<span class="keyword">instancetype</span>)init;</div><div class="line"><span class="comment">//从归档初始化</span></div><div class="line">- (<span class="keyword">instancetype</span>)initWithCoder:(<span class="built_in">NSCoder</span> *)coder;</div><div class="line"><span class="comment">//加载视图</span></div><div class="line">-(<span class="keyword">void</span>)loadView;</div><div class="line"><span class="comment">//将要加载视图</span></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad;</div><div class="line"><span class="comment">//将要布局子视图</span></div><div class="line">-(<span class="keyword">void</span>)viewWillLayoutSubviews;</div><div class="line"><span class="comment">//已经布局子视图</span></div><div class="line">-(<span class="keyword">void</span>)viewDidLayoutSubviews;</div><div class="line"><span class="comment">//内存警告</span></div><div class="line">- (<span class="keyword">void</span>)didReceiveMemoryWarning;</div><div class="line"><span class="comment">//已经展示</span></div><div class="line">-(<span class="keyword">void</span>)viewDidAppear:(<span class="built_in">BOOL</span>)animated;</div><div class="line"><span class="comment">//将要展示</span></div><div class="line">-(<span class="keyword">void</span>)viewWillAppear:(<span class="built_in">BOOL</span>)animated;</div><div class="line"><span class="comment">//将要消失</span></div><div class="line">-(<span class="keyword">void</span>)viewWillDisappear:(<span class="built_in">BOOL</span>)animated;</div><div class="line"><span class="comment">//已经消失</span></div><div class="line">-(<span class="keyword">void</span>)viewDidDisappear:(<span class="built_in">BOOL</span>)animated;</div><div class="line"><span class="comment">//被释放</span></div><div class="line">-(<span class="keyword">void</span>)dealloc;</div></pre></td></tr></table></figure></p>
<p>除了<code>initialize,init</code>和<code>initWithCoder</code>不是存在所有对象的声明周期中，其他函数都会在UIViewController的声明周期中有序的被调用。那么具体的调用顺序是怎样的呢，最好的办法是实践一下，通过编号打印，结果如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">initialize <span class="comment">// initialize函数并不会每次创建对象都调用，只有在这个类第一次创建对象时才会调用，做一些类的准备工作，再次创建这个类的对象，initalize方法将不会被调用，对于这个类的子类，如果实现了initialize方法，在这个子类第一次创建对象时会调用自己的initalize方法，之后不会调用，如果没有实现，那么它的父类将替它再次调用一下自己的initialize方法，以后创建也都不会再调用。因此，如果我们有一些和这个相关的全局变量，可以在这里进行初始化。</span></div><div class="line">init <span class="comment">// init方法和initCoder方法相似，只是被调用的环境不一样，如果用代码进行初始化，会调用init，从nib文件或者归档进行初始化，会调用initCoder。</span></div><div class="line">loadView <span class="comment">// 开始加载视图的起始方法，除非手动调用，否则在ViewController的生命周期中没特殊情况只会被调用一次。</span></div><div class="line">viewDidLoad <span class="comment">// 这是是我们最常用的方法的，类中成员对象和变量的初始化我们都会放在这个方法中，在类创建后，无论视图的展现或消失，这个方法也是只会在将要布局时调用一次。</span></div><div class="line">viewWillAppear <span class="comment">// 视图将要展现时会调用</span></div><div class="line">viewWillLayoutSubviews <span class="comment">// 在viewWillAppear后调用，将要对子视图进行布局</span></div><div class="line">viewDidLayoutSubviews  <span class="comment">// 已经布局完成子视图</span></div><div class="line">viewDidAppare <span class="comment">// 视图完成显示时调用</span></div><div class="line">viewWillDisappear <span class="comment">// 视图将要消失时调用</span></div><div class="line">viewDidDisappear <span class="comment">// 视图已经消失时调用</span></div><div class="line">dealloc <span class="comment">// controller被释放时调用。</span></div></pre></td></tr></table></figure></p>
<p>参考文章：<a href="https://my.oschina.net/u/2340880/blog/524564" target="_blank" rel="external">iOS对UIViewController生命周期和属性方法的解析</a></p>
<p>说下遇到的一道选择题：如果页面A跳转到页面B，以下选项正确的是（）？<br>A、A页面的 viewDidDisappear 方法先调用；<br>B、B页面的 viewDidAppear 方法先调用；<br>C、不一定，都有可能；</p>
<p>答案 我是选的B<br>不过准确的说应该分情况而定，经过实际测试发现如果是push跳转的话，执行顺序是<br>页面A - <code>[ViewControllerA viewDidDisappear:]</code><br>页面B - <code>[ViewControllerB viewDidAppear:]</code><br>如果是present跳转的话，执行顺序是<br>页面B - <code>[ViewControllerB viewDidAppear:]</code><br>页面A - <code>[ViewControllerA viewDidDisappear:]</code><br>如有不对，感谢纠正。</p>
<h4 id="11-如何对下面数组中的元素去重（代码，伪代码，思路都可以）？"><a href="#11-如何对下面数组中的元素去重（代码，伪代码，思路都可以）？" class="headerlink" title="11. 如何对下面数组中的元素去重（代码，伪代码，思路都可以）？"></a>11. 如何对下面数组中的元素去重（代码，伪代码，思路都可以）？</h4><p><code>NSArray *array = @[@&quot;12-11&quot;, @&quot;12-11&quot;, @&quot;12-11&quot;, @&quot;12-12&quot;, @&quot;12-13&quot;, @&quot;12-12&quot;];</code></p>
<p>1）利用<code>containsObject</code>判断<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSMutableArray</span> *mutArray = [<span class="built_in">NSMutableArray</span> array];</div><div class="line">   <span class="keyword">for</span> (<span class="built_in">NSString</span> *value <span class="keyword">in</span> array) &#123;</div><div class="line">       <span class="keyword">if</span> (![mutArray containsObject:value]) &#123;</div><div class="line">           [mutArray addObject:value];</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>2）利用NSSet自动去重特性<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSMutableSet</span> *mutSet = [<span class="built_in">NSMutableSet</span> set];</div><div class="line">   <span class="keyword">for</span> (<span class="built_in">NSString</span> *value <span class="keyword">in</span> array) &#123;</div><div class="line">       [mutSet addObject:value];</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>以上是自己写的两种方法，若有更好的答案感谢告知。</p>
<h4 id="12-请问下面的代码会输出什么？为什么？"><a href="#12-请问下面的代码会输出什么？为什么？" class="headerlink" title="12. 请问下面的代码会输出什么？为什么？"></a>12. 请问下面的代码会输出什么？为什么？</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ClassB</span> : <span class="title">ClassA</span></span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ClassB</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">id</span>)init &#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> <span class="keyword">class</span>]));</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="built_in">NSStringFromClass</span>([<span class="keyword">super</span> <span class="keyword">class</span>]));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>两句输出语句均输出：ClassB<br>简单来说，self和super都是指向当前实例的，不同的是<code>[self class]</code>会在当前类的方法列表中去找class这个方法，<code>[super class]</code>会直接开始在当前类的父类中去找calss这个方法，两者在找不到的时候，都会继续向祖类查询class方法，最终到NSObject类。那么问题来了，由于我们在ClassA和ClassB中都没有去重写class这个方法，最终自然都会去执行NSObject中的class方法，结果也自然应该是一样的。至于为什么是ClassB，可以看看NSObject中class的实现：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (Class)<span class="keyword">class</span> &#123;</div><div class="line">    <span class="keyword">return</span> object_getClass(<span class="keyword">self</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>返回的都是self的类型，self此处正好就是ClassB，因此结果就会输出ClassB。<br>参考链接：<a href="https://github.com/BaiduHiDeviOS/iOS-puzzles/issues/1" target="_blank" rel="external">有关super和self的问题</a></p>
<h4 id="13-说说你常使用的lldb调试命令？"><a href="#13-说说你常使用的lldb调试命令？" class="headerlink" title="13. 说说你常使用的lldb调试命令？"></a>13. 说说你常使用的lldb调试命令？</h4><p>LLDB是Xcode默认的调试器，它与LLVM编译器一起，带给我们更丰富的流程控制和数据检测的调试功能。平时用Xcode运行程序，实际走的都是LLDB。熟练使用LLDB，可以让debug事半功倍。<br>常用LLDB命令:</p>
<ul>
<li><p>expression<br>expression命令的作用是执行一个表达式，并将表达式返回的结果输出。可以实现2个功能：<br>  1) 执行某个表达式。 我们在代码运行过程中，可以通过执行某个表达式来动态改变程序运行的轨迹。 假如我们在运行过程中，突然想把self.view颜色改成红色，看看效果。我们不必写下代码，重新run，只需暂停程序，用expression改变颜色，再刷新一下界面，就能看到效果<br>  <img src="http://oo8l3jrvb.bkt.clouddn.com/expr_lldb.png" alt="image"></p>
<p>  2) 将返回值输出。 也就是说我们可以通过expression来打印东西。 假如我们想打印self.view<br>  <img src="http://oo8l3jrvb.bkt.clouddn.com/expr2_lldb.png" alt="image"></p>
</li>
<li>p &amp; print &amp; call<br>print: 打印某个东西，可以是变量和表达式<br>p: 可以看做是print的简写<br>call: 调用某个方法</li>
<li>po<br>OC里所有的对象都是用指针表示的，所以一般打印的时候，打印出来的是对象的指针，而不是对象本身。如果我们想打印对象。我们需要使用命令选项:-O。为了更方便的使用，LLDB为<code>expression -O</code> 定义了一个别名：po<blockquote>
<p>还有其他很多命令选项，不过一般用得比较少，所以就不具体的一一介绍了，如果想了解，在LLDB控制台上输入：help expression即可查到expression所有的信息</p>
</blockquote>
</li>
</ul>
<p>该题图片内容来自：<a href="http://ios.jobbole.com/83393/" target="_blank" rel="external">熟练使用 LLDB，让你调试事半功倍</a></p>
<h4 id="14-如下ViewB是ViewA的子视图，其中1-4的区域在父视图ViewA上，如何让ViewB的3-4区域也响应事件？"><a href="#14-如下ViewB是ViewA的子视图，其中1-4的区域在父视图ViewA上，如何让ViewB的3-4区域也响应事件？" class="headerlink" title="14. 如下ViewB是ViewA的子视图，其中1/4的区域在父视图ViewA上，如何让ViewB的3/4区域也响应事件？"></a>14. 如下ViewB是ViewA的子视图，其中1/4的区域在父视图ViewA上，如何让ViewB的3/4区域也响应事件？</h4><p><img src="http://oo8l3jrvb.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-05-14%20%E4%B8%8B%E5%8D%8812.06.32.png" alt="image"></p>
<p>参考这里：<a href="https://snail-z.github.io/2017/05/13/Cocoa%20Touch中的响应者链/" target="_blank" rel="external">Cocoa Touch中的响应者链</a></p>
<h4 id="15-谈谈你对MVVM与MVC的理解？"><a href="#15-谈谈你对MVVM与MVC的理解？" class="headerlink" title="15. 谈谈你对MVVM与MVC的理解？"></a>15. 谈谈你对MVVM与MVC的理解？</h4><h4 id="16-什么是Runloop？"><a href="#16-什么是Runloop？" class="headerlink" title="16. 什么是Runloop？"></a>16. 什么是Runloop？</h4>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录一下自己最近面试过程中遇到的一些面试题。&lt;/p&gt;
&lt;h4 id=&quot;1-OC中-property的作用是什么？可以有哪些关键字修饰？&quot;&gt;&lt;a href=&quot;#1-OC中-property的作用是什么？可以有哪些关键字修饰？&quot; class=&quot;headerlink&quot; title=&quot;1. OC中@property的作用是什么？可以有哪些关键字修饰？&quot;&gt;&lt;/a&gt;1. OC中@property的作用是什么？可以有哪些关键字修饰？&lt;/h4&gt;&lt;p&gt;@Property是声明属性的语法，作为OC的一项特性，主要作用就在于封装对象中的数据。可以快速方便的为实例变量创建存取器，并允许通过点语法使用存取器。&lt;br&gt;@property本质就是ivar(实例变量) 和 getter / setter(存取方法)。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;存取器（accessor）：用于获取和设置实例变量的方法。用于获取实例变量值的存取器是getter，用于设置实例变量值的存取器是setter。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;关键字修饰：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线程安全的(关于是否原子访问): &lt;code&gt;atomic, nonatomic&lt;/code&gt; &lt;/li&gt;
&lt;li&gt;访问权限的(关于访问控制操作): &lt;code&gt;readonly, readwrite&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;内存管理(MRC)(关于set方法中属性引用计数相关): &lt;code&gt;assign, retain, copy&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;内存管理(ARC)(增加了weak、strong属性): &lt;code&gt;assign, strong, weak, copy&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;指定方法名称: &lt;code&gt;getter=  / setter=&lt;/code&gt;
    
    </summary>
    
      <category term="技术" scheme="http://note.snail-z.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="iOS" scheme="http://note.snail-z.me/tags/iOS/"/>
    
      <category term="面试题" scheme="http://note.snail-z.me/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Cocoa Touch中的响应者链</title>
    <link href="http://note.snail-z.me/2017/05/13/Cocoa%20Touch%E4%B8%AD%E7%9A%84%E5%93%8D%E5%BA%94%E8%80%85%E9%93%BE/"/>
    <id>http://note.snail-z.me/2017/05/13/Cocoa Touch中的响应者链/</id>
    <published>2017-05-13T04:33:29.000Z</published>
    <updated>2017-05-13T16:19:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>了解Cocoa Touch中的响应者链之前，先通过下图了解一下有关UIView的继承关系：<br><img src="http://oo8l3jrvb.bkt.clouddn.com/timg2.jpg" alt="image"></p>
<blockquote>
<p><code>UIView</code>继承自<code>UIResponder</code> , <code>UIResponder</code>继承自<code>NSObject</code></p>
</blockquote>
<p>（上图是从我从网上找个一张关系图，如有侵权请及时告知）</p>
<h2 id="响应者链（Responder-Chain）"><a href="#响应者链（Responder-Chain）" class="headerlink" title="响应者链（Responder Chain）"></a>响应者链（Responder Chain）</h2><p>对于 iOS 设备用户来说，他们操作设备的方式主要有三种：触摸屏幕、晃动设备、通过遥控设施控制设备。对应的事件类型有以下三种：<br>    触屏事件（Touch Event）<br>    运动事件（Motion Event）<br>    远端控制事件（Remote-Control Event）<br><a id="more"></a><br>在iOS中，当发生事件响应时，由响应者链来对事件进行响应。<br>所有事件响应的类都是 UIResponder 的子类，响应者链是一个由不同对象组成的层次结构，其中的每个对象将依次获得响应事件消息的机会。当发生事件时，事件首先被发送给第一响应者，第一响应者往往是事件发生的视图，也就是用户触摸屏幕的地方。事件将沿着响应者链一直向下传递，直到被接受并做出处理。一般来说，第一响应者是个视图对象或者其子类对象，当其被触摸后事件被交由它处理，如果它不处理，事件就会被传递给它的视图控制器对象 ViewController（如果存在），然后是它的父视图（superview）对象（如果存在），以此类推，直到顶层视图。接下来会沿着顶层视图（top view）到窗口（UIWindow 对象）再到程序（UIApplication 对象）。如果整个过程都没有响应这个事件，该事件就被丢弃。一般情况下，在响应者链中只要由对象处理事件，事件就停止传递。</p>
<h2 id="事件分发（Event-Delivery）"><a href="#事件分发（Event-Delivery）" class="headerlink" title="事件分发（Event Delivery）"></a>事件分发（Event Delivery）</h2><p>第一响应者（First responder）指的是当前接受触摸的响应者对象（通常是一个UIView对象），即表示当前该对象正在与用户交互，它是响应者链的开端。整个响应者链和事件分发的使命都是找出第一响应者。<br>iOS 系统检测到手指触摸 (Touch) 操作时会将其打包成一个 UIEvent 对象，并放入当前活动 Application 的事件队列，单例的 UIApplication 会从事件队列中取出触摸事件并传递给单例的 UIWindow 来处理，UIWindow 对象首先会使用 hitTest:withEvent:方法寻找此次 Touch 操作初始点所在的视图(View)，即需要将触摸事件传递给其处理的视图，这个过程称之为 hit-test view。<br><code>hitTest:withEvent:</code>方法的处理流程如下:</p>
<ul>
<li>首先调用当前视图的 <code>pointInside:withEvent:</code> :该方法用来判断点击事件发生的位置是否处于当前视图范围内，以确定用户是不是点击了当前视图，如果<code>pointInside:withEvent:</code>返回YES，则继续逐级调用，则向当前视图的所有子视图 (subviews) 发送<code>hitTest:withEvent:</code>消息，所有子视图的遍历顺序是从最顶层视图一直到到最底层视图，即从subviews数组的末尾向前遍历，直到有子视图返回非空对象或者全部子视图遍历完毕；</li>
<li>若第一次有子视图返回非空对象，则<code>hitTest:withEvent:</code>方法返回此对象，处理结束；</li>
<li>如所有子视图都返回空，则<code>hitTest:withEvent:</code>方法返回自身 (self)。</li>
</ul>
<blockquote>
<p>如果一个子视图的区域超过父视图的 bound 区域(父视图的 clipsToBounds 属性为 NO，这样超过父视图 bound 区域的子视图内容也会显示)，那么正常情况下对子视图在父视图之外区域的触摸操作不会被识别, 因为父视图的<code>pointInside:withEvent:</code>方法会返回 NO, 这样就不会继续向下遍历子视图了。当然，也可以重写<code>pointInside:withEvent:</code>方法来处理这种情况。也可以重写 <code>hitTest:withEvent:</code>来达到某些特定的目的。</p>
</blockquote>
<p>例如：为了支持视图上的按钮大小超过视图的Frame范围时也可以响应，可以重载<code>hitTest</code>方法：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">UIView</span> *)hitTest:(<span class="built_in">CGPoint</span>)point withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.userInteractionEnabled &amp;&amp; !<span class="keyword">self</span>.hidden &amp;&amp; <span class="keyword">self</span>.alpha &gt; <span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="built_in">UIView</span> *subview <span class="keyword">in</span> <span class="keyword">self</span>.subviews) &#123;</div><div class="line">            <span class="built_in">CGPoint</span> p = [subview convertPoint:point fromView:<span class="keyword">self</span>];</div><div class="line">            <span class="built_in">UIView</span> *result = [subview hitTest:p withEvent:event];</div><div class="line">            <span class="keyword">if</span> (<span class="literal">nil</span> != result) &#123;</div><div class="line">                <span class="keyword">return</span> result;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到上面代码主要就在于取消了<code>pointInside</code>函数的检测，让我们可以捕获到当前 Frame 范围以外的子 View 的触控事件。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://hit-alibaba.github.io/interview/iOS/Cocoa-Touch/Event-Handling.html" target="_blank" rel="external">事件处理-iOS面试题</a></li>
<li><a href="http://blog.csdn.net/wzzvictory/article/details/9264335" target="_blank" rel="external">Cocoa Touch事件处理流程–响应者链</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;了解Cocoa Touch中的响应者链之前，先通过下图了解一下有关UIView的继承关系：&lt;br&gt;&lt;img src=&quot;http://oo8l3jrvb.bkt.clouddn.com/timg2.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;UIView&lt;/code&gt;继承自&lt;code&gt;UIResponder&lt;/code&gt; , &lt;code&gt;UIResponder&lt;/code&gt;继承自&lt;code&gt;NSObject&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;（上图是从我从网上找个一张关系图，如有侵权请及时告知）&lt;/p&gt;
&lt;h2 id=&quot;响应者链（Responder-Chain）&quot;&gt;&lt;a href=&quot;#响应者链（Responder-Chain）&quot; class=&quot;headerlink&quot; title=&quot;响应者链（Responder Chain）&quot;&gt;&lt;/a&gt;响应者链（Responder Chain）&lt;/h2&gt;&lt;p&gt;对于 iOS 设备用户来说，他们操作设备的方式主要有三种：触摸屏幕、晃动设备、通过遥控设施控制设备。对应的事件类型有以下三种：&lt;br&gt;    触屏事件（Touch Event）&lt;br&gt;    运动事件（Motion Event）&lt;br&gt;    远端控制事件（Remote-Control Event）&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://note.snail-z.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="iOS" scheme="http://note.snail-z.me/tags/iOS/"/>
    
      <category term="Objective-C" scheme="http://note.snail-z.me/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>UICollectionView学习笔记</title>
    <link href="http://note.snail-z.me/2017/04/10/UICollectionView%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://note.snail-z.me/2017/04/10/UICollectionView学习笔记/</id>
    <published>2017-04-10T11:56:34.000Z</published>
    <updated>2017-04-18T02:56:55.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>UICollectionView</code>的显示效果几乎全部由<code>UICollectionViewLayout</code>负责，而真正存储着每一个 Cell 的位置、大小等属性的是<code>UICollectionViewLayoutAttributes</code>。每个Cell都对应着一个属于自己的<code>UICollectionViewLayoutAttributes</code>，包含中心点，大小，形状，透明度和层次关系等等。<br>而 <code>UICollectionViewLayout</code>正是利用<code>UICollectionViewLayoutAttributes</code>里存在的信息对每一个Cell进行布局的。<br><a id="more"></a></p>
<h3 id="UICollectionViewLayout"><a href="#UICollectionViewLayout" class="headerlink" title="UICollectionViewLayout"></a>UICollectionViewLayout</h3><ul>
<li><p><code>-(void)prepareLayout</code><br>专门用来准备布局的，在布局之前，它会调用一次，之后只有在调用 shouldInvalidateLayoutForBoundsChange: 方法并返回YES、调用<code>invalidateLayout</code>方法和 UICollectionView 刷新的时候才会重新调用。因此，我们通常在这个方法中进行一些一次性的设置和计算，如cell中固定的布局属性等以提高性能。切记调用<code>[super prepareLayout];</code></p>
</li>
<li><p><code>-(CGSize)collectionViewContentSize</code><br>返回collectionView的内容尺寸，相当于scrollView的contentSize，同样的，由于此方法会多次调用，最好在<code>prepareLayout</code> 方法中进行尺寸计算</p>
</li>
<li><p><code>-(NSArray *)layoutAttributesForElementsInRect:(CGRect)rect</code><br>这个方法是返回某个特定区域的布局的属性的数据集合。返回存放的都是<code>UICollectionViewLayoutAttributes</code>对象的数组。<br>该方法比较迷惑的是<code>rect</code>，具体的<code>rect</code>既不是当前<code>CollectionView</code>的<code>size</code>也不是<code>ContentSize</code>，也不是当前真正的可见范围，而是比可见范围大比<code>ContentSize</code>小的一块区域（貌似用屏幕的高的倍数设置的区域），用来缓冲布局，比如说现在视线能看到两个item视图，这个rect大约会是可以显示4个item的范围，好用来提前布局看不到的附近的item，这样滚动时就会看着像全部已经布局好了一样！所以为了性能起见，这个方法内不应该返回所有的item的Attributes 而是应该在区域内的Attributes。相当于预先布局上一个或者下一个item<br>可以参考这篇文章：<a href="https://www.intertech.com/Blog/ios-uicollectionview-tutorial-4-custom-layout-with-scrolling-support-for-collection-views/" target="_blank" rel="external">https://www.intertech.com/Blog/ios-uicollectionview-tutorial-4-custom-layout-with-scrolling-support-for-collection-views/</a><br>实现需要做这几步：<br>创建一个空的可变数组来存放所有的布局属性。<br>确定<code>index paths</code>中哪些<code>cells</code>的<code>frame</code>完全或部分位于矩形中。这个计算需要你从collection view的数据源中取出你需要显示的数据。然后在循环中调用你实现的<code>layoutAttributesForItemAtIndexPath:</code>方法为每个<code>index path</code>创建并配置一个合适的布局属性对象，并将每个对象添加到数组中。<br>如果布局中包含<code>supplementary views</code>，计算矩形内可见<code>supplementaryView</code>的<code>index paths</code>，在循环中调用你实现的<br><code>layoutAttributesForSupplementaryViewOfKind:atIndexPath:</code>，<br>并且将这些对象加到数组中。通过为 kind 参数传递你选择的不同字符，你可以区分出不同种类的<code>supplementary views</code>（比如headers和footers）。当需要创建视图时，collection view 会将 kind 字符传回到你的数据源。记住<code>supplementary</code>和<code>decoration views</code>的数量和种类完全由布局控制。不会受到 headers 和 footers 的限制。<br>如果布局包含<code>decoration views</code>，计算矩形内可见<code>decoration views</code>的<code>index paths</code>，再在循环中调用你实现的 <code>layoutAttributesForDecorationViewOfKind:atIndexPath:</code>  并且将这些对象加到数组中。<br>最后返回数组。</p>
</li>
<li><p><code>-(UICollectionViewLayoutAttributes _)layoutAttributesForItemAtIndexPath:</code><br>需要创建并返回对应于indexPath的位置的cell的布局属性对象。<br>比如滚动时候将item背景，frame或者其他属性设置修改，应该在这个方法里实现。通过调用 <code>+[UICollectionViewLayoutAttributes layoutAttributesForCellWithIndexPath:]</code>这个方法，获取到cell的Attributes属性然后进行一系列的修改设置</p>
</li>
<li><p>-(BOOL)shouldInvalidateLayoutForBoundsChange:(CGRect)newBounds<code>最后，当</code>collection view<code>的</code>bounds<code>改变时，布局需要告诉</code>collection view`是否需要重新计算布局。比如需要动态控制 UICollectionViewLayoutAttributes，就需要调用该方法并返回YES。为了提高性能，应该比较视图当前的bounds和新的bounds来确定返回值：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)shouldInvalidateLayoutForBoundsChange:(<span class="built_in">CGRect</span>)newBounds &#123;</div><div class="line">    <span class="built_in">CGRect</span> oldBounds = <span class="keyword">self</span>.collectionView.bounds;</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">CGRectGetWidth</span>(newBounds) != <span class="built_in">CGRectGetWidth</span>(oldBounds)) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">    &#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><code>-(CGPoint)targetContentOffsetForProposedContentOffset:(CGPoint)proposedContentOffset withScrollingVelocity:(CGPoint)velocity</code><br>当在拖动的時候，手指抬起时调用。当滑动停止时，希望<code>UICollectionView</code>滑动到某个位置（如中心位置），而不是任意位置。重载该方法，其中<code>proposedContentOffset</code>为系统期望滑动到的位置，<code>velocity</code>为加速度，可以通过这两个参数以及当前所在的位置计算出你希望它滑动到的位置，具体算法根据需求的不同来实现<br><code>proposedContentOffset：</code>默认情况下CollectionView停止滚动时最终的偏移量。<br><code>velocity：</code>滚动速率，通过这个参数可以了解滚动的方向。返回值决定了collectionView停止滚动时最终的偏移量contentOffset;（最终collectionView停到哪个位置的偏移量）</p>
</li>
</ul>
<h3 id="UICollectionViewLayoutAttributes"><a href="#UICollectionViewLayoutAttributes" class="headerlink" title="UICollectionViewLayoutAttributes"></a>UICollectionViewLayoutAttributes</h3><p><code>UICollectionViewLayout</code>实际上是通过<code>UICollectionViewLayoutAttributes</code>类来实现布局的，每一个<code>UICollectionView</code>内容视图都对应一个 <code>UICollectionViewLayoutAttributes</code>对象。可以说自定义布局的主要精力都用在设置<code>UICollectionViewLayoutAttributes</code>上。</p>
<p>属性列表：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">CGRect</span> frame;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">CGPoint</span> center;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">CGSize</span> size;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">CATransform3D</span> transform3D; <span class="comment">// 配置item的3D效果</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">CGRect</span> bounds;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">CGAffineTransform</span> transform;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">CGFloat</span> alpha;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSInteger</span> zIndex; <span class="comment">// z轴(垂直于屏幕的轴)优先级，默认为0，越大优先级越高</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">getter</span>=isHidden) <span class="built_in">BOOL</span> hidden; <span class="comment">// 是否隐藏；从优化性能考虑，隐藏的对象不会被创建</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSIndexPath</span> *indexPath;</div></pre></td></tr></table></figure></p>
<p>方法列表：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">+ (<span class="keyword">instancetype</span>)layoutAttributesForCellWithIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath;</div><div class="line">+ (<span class="keyword">instancetype</span>)layoutAttributesForSupplementaryViewOfKind:(<span class="built_in">NSString</span> *)elementKind withIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath;</div><div class="line">+ (<span class="keyword">instancetype</span>)layoutAttributesForDecorationViewOfKind:(<span class="built_in">NSString</span> *)decorationViewKind withIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath;</div></pre></td></tr></table></figure></p>
<p>因为<code>UICollectionView</code>的Cell视图、Supplementary视图还是Decoration视图都是通过它们的 <code>attributes（UICollectionViewLayoutAttributes）</code>来定义的。所以可以定义一个<code>UICollectionViewLayoutAttributes</code>子类，并设置自定义属性。注意：自定义的属性只能通过<code>UICollectionReusableView</code>的<br> <code>- (void)applyLayoutAttributes:(UICollectionViewLayoutAttributes *)layoutAttributes</code><br> 方法在<code>CollectionView</code>布局时来使之生效。</p>
<h3 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h3><ul>
<li>设置如何每个item充满屏幕，并让其滚动时有一定的间距：<br><a href="http://stackoverflow.com/questions/29658328/uicollectionview-horizontal-paging-not-centered" target="_blank" rel="external">http://stackoverflow.com/questions/29658328/uicollectionview-horizontal-paging-not-centered</a></li>
</ul>
<h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p><a href="https://objccn.io/issue-3-3/" target="_blank" rel="external">ObjC中国 - 自定义Collection View布局</a><br><a href="https://onevcat.com/2012/08/advanced-collection-view/" target="_blank" rel="external">WWDC 2012 Session笔记-UICollectionView</a><br><a href="https://toutiao.io/posts/jyvufj/preview" target="_blank" rel="external">使用 UICollectionView 实现的一个卡片动画（Swift）</a><br><a href="http://summertreee.github.io/blog/2016/07/25/bu-ju-mo-hua-tong-:uicolletionview/" target="_blank" rel="external">布局万花筒：UIColletionview</a><br><a href="http://lixuzong.com/2016/11/24/UICollectionView_note/" target="_blank" rel="external">UICollectionView与iCarousel</a><br><a href="http://c0ming.me/different-section-background-color/" target="_blank" rel="external">为 UICollectionView 设置不同的 Section 背景颜色</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;UICollectionView&lt;/code&gt;的显示效果几乎全部由&lt;code&gt;UICollectionViewLayout&lt;/code&gt;负责，而真正存储着每一个 Cell 的位置、大小等属性的是&lt;code&gt;UICollectionViewLayoutAttributes&lt;/code&gt;。每个Cell都对应着一个属于自己的&lt;code&gt;UICollectionViewLayoutAttributes&lt;/code&gt;，包含中心点，大小，形状，透明度和层次关系等等。&lt;br&gt;而 &lt;code&gt;UICollectionViewLayout&lt;/code&gt;正是利用&lt;code&gt;UICollectionViewLayoutAttributes&lt;/code&gt;里存在的信息对每一个Cell进行布局的。&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://note.snail-z.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="iOS" scheme="http://note.snail-z.me/tags/iOS/"/>
    
      <category term="Objective-C" scheme="http://note.snail-z.me/tags/Objective-C/"/>
    
      <category term="集合视图" scheme="http://note.snail-z.me/tags/%E9%9B%86%E5%90%88%E8%A7%86%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C笔记</title>
    <link href="http://note.snail-z.me/2017/04/07/Objective-C%E7%AC%94%E8%AE%B0/"/>
    <id>http://note.snail-z.me/2017/04/07/Objective-C笔记/</id>
    <published>2017-04-07T13:56:56.000Z</published>
    <updated>2017-05-13T04:35:01.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="UIScrollview上的UIPangesturerecognizer冲突"><a href="#UIScrollview上的UIPangesturerecognizer冲突" class="headerlink" title="UIScrollview上的UIPangesturerecognizer冲突"></a>UIScrollview上的UIPangesturerecognizer冲突</h2><p>在tableview里的cell的imageview上加个UIPangesturerecognizer会发现优先滚动imageview，tableView不响应滚动了，原因是tableview的实现也是用了UIPangesturerecognizer。解决方案如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 实现 UIGestureRecognizerDelegate</span></div><div class="line">- (<span class="built_in">BOOL</span>)gestureRecognizer:(<span class="built_in">UIGestureRecognizer</span> *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(<span class="built_in">UIGestureRecognizer</span> *)otherGestureRecognizer &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<h2 id="CGRect函数"><a href="#CGRect函数" class="headerlink" title="CGRect函数"></a>CGRect函数</h2><ul>
<li><p>CGRectOffset使用从源CGRect偏移的原点来创建矩形</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">float</span> offset = <span class="number">25.0</span>;</div><div class="line">    <span class="built_in">CGRect</span> r1 = <span class="built_in">CGRectMake</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>);</div><div class="line">    <span class="built_in">CGRect</span> r2 = <span class="built_in">CGRectOffset</span>(r1, offset, offset);</div></pre></td></tr></table></figure>
</li>
<li><p>CGRectIntersectsRect允许我们确定两个矩形是否相交</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">float</span> offset = <span class="number">25.0</span>;</div><div class="line">    <span class="built_in">CGRect</span> r1 = <span class="built_in">CGRectMake</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>);</div><div class="line">    <span class="built_in">CGRect</span> r2 = <span class="built_in">CGRectMake</span>(<span class="number">150</span>, <span class="number">150</span>, <span class="number">100</span>, <span class="number">100</span>);</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">CGRectIntersectsRect</span>(r1, r2))</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"intersecting"</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>NSStringFromCGRect可以用来把CGRect显示到控制台</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">    <span class="built_in">CGRect</span> r1 = <span class="built_in">CGRectMake</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"rect:@%"</span>,<span class="built_in">NSStringFromCGRect</span>(r1));  </div><div class="line"><span class="comment">// 同样，CGRectFromString允许我们根据一个字符串创建一个CGRect：</span></div><div class="line">    <span class="built_in">NSString</span> *r = <span class="string">@"&#123;0,0&#125;,&#123;100,100&#125;"</span>;</div><div class="line">    <span class="built_in">CGRect</span> r1 = <span class="built_in">CGRectFromString</span>(r);</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="为视图某个角添加圆角"><a href="#为视图某个角添加圆角" class="headerlink" title="为视图某个角添加圆角"></a>为视图某个角添加圆角</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPathWithRoundedRect:aView.layer.bounds</div><div class="line">                                       byRoundingCorners:<span class="built_in">UIRectCornerTopLeft</span> | <span class="built_in">UIRectCornerBottomRight</span></div><div class="line">                                             cornerRadii:<span class="built_in">CGSizeMake</span>(<span class="number">25</span>, <span class="number">0</span>)];</div><div class="line"><span class="built_in">CAShapeLayer</span> *roundRectLayer = [[<span class="built_in">CAShapeLayer</span> alloc] init];</div><div class="line">roundRectLayer.frame  = aView.layer.bounds;</div><div class="line">roundRectLayer.path = path.CGPath;</div><div class="line">aView.layer.mask = roundRectLayer;</div><div class="line">aView.clipsToBounds = <span class="literal">NO</span>;</div></pre></td></tr></table></figure>
<p>若配置某个角为圆角的话,只需要指定对应的UIRectCorner即可：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UIRectCornerAllCorners</span> 	全角</div><div class="line"><span class="built_in">UIRectCornerTopLeft</span>    	左上角</div><div class="line"><span class="built_in">UIRectCornerTopRight</span>   	右上角</div><div class="line"><span class="built_in">UIRectCornerBottomLeft</span> 	左下角</div><div class="line"><span class="built_in">UIRectCornerBottomRight</span> 右下角</div></pre></td></tr></table></figure></p>
<h2 id="设置UITableView的分割线顶头"><a href="#设置UITableView的分割线顶头" class="headerlink" title="设置UITableView的分割线顶头"></a>设置UITableView的分割线顶头</h2><p>使用setSeparatorInset:UIEdgeInsetsZero来解决：</p>
<ol>
<li><p>直接对tableView进行设置：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ([_tableView respondsToSelector:<span class="keyword">@selector</span>(setSeparatorInset:)]) &#123;</div><div class="line">    [_tableView setSeparatorInset:<span class="built_in">UIEdgeInsetsZero</span>];</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> ([_tableView respondsToSelector:<span class="keyword">@selector</span>(setLayoutMargins:)]) &#123;</div><div class="line">    [_tableView setLayoutMargins:<span class="built_in">UIEdgeInsetsZero</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>实现UITableViewDelegate的代理方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)tableView:(<span class="built_in">UITableView</span> *)tableView willDisplayCell:(<span class="built_in">UITableViewCell</span> *)cell forRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</div><div class="line">    <span class="keyword">if</span> ([cell respondsToSelector:<span class="keyword">@selector</span>(setSeparatorInset:)]) &#123;</div><div class="line">        [cell setSeparatorInset:<span class="built_in">UIEdgeInsetsZero</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> ([cell respondsToSelector:<span class="keyword">@selector</span>(setLayoutMargins:)]) &#123;</div><div class="line">        [cell setLayoutMargins:<span class="built_in">UIEdgeInsetsZero</span>];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>去掉分割线 <code>_tableView.separatorStyle = UITableViewCellSeparatorStyleNone;</code></p>
<h2 id="Frame布局时使用CGRectInset设置左右、上下边距"><a href="#Frame布局时使用CGRectInset设置左右、上下边距" class="headerlink" title="Frame布局时使用CGRectInset设置左右、上下边距"></a>Frame布局时使用CGRectInset设置左右、上下边距</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UIView</span> *aView = [[<span class="built_in">UIView</span> alloc] initWithFrame:<span class="built_in">CGRectInset</span>(<span class="keyword">self</span>.view.bounds, <span class="number">10</span>, <span class="number">100</span>)];</div><div class="line">aView.backgroundColor = [<span class="built_in">UIColor</span> orangeColor];</div><div class="line">[<span class="keyword">self</span>.view addSubview:aView];</div></pre></td></tr></table></figure>
<h2 id="PCH文件配置"><a href="#PCH文件配置" class="headerlink" title="PCH文件配置"></a>PCH文件配置</h2><p>如图：在Build Settings内搜索<code>prefix header</code><br><img src="http://oo8l3jrvb.bkt.clouddn.com/pch%20configuration.png" width="550px" height="330px"><br>然后修改为<code>$(SRCROOT)/Mydemo/MydemoPrefixHeader.pch</code><br>其中<code>Mydemo</code>对应project name, <code>MydemoPrefixHeader.pch</code>对应PCH file</p>
<h2 id="查找在数组中NSNumber的最大值和最小值"><a href="#查找在数组中NSNumber的最大值和最小值" class="headerlink" title="查找在数组中NSNumber的最大值和最小值"></a>查找在数组中NSNumber的最大值和最小值</h2><p>参考：<br><a href="http://stackoverflow.com/questions/15931112/finding-the-smallest-and-biggest-value-in-nsarray-of-nsnumbers" target="_blank" rel="external">http://stackoverflow.com/questions/15931112/finding-the-smallest-and-biggest-value-in-nsarray-of-nsnumbers</a></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)sample &#123;</div><div class="line">    </div><div class="line">    <span class="built_in">NSArray</span> *array = @[@<span class="number">8.091</span>, @<span class="number">0.31</span>, @<span class="number">10.55</span>, @<span class="number">50.5</span>, @<span class="number">5.50</span>, @<span class="number">0.31</span>];</div><div class="line">    </div><div class="line">    <span class="built_in">NSNumber</span> *maxValue = [array valueForKeyPath:<span class="string">@"@max.self"</span>];</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"maxValue - %@"</span>, maxValue); <span class="comment">// maxValue - 50.5</span></div><div class="line">    </div><div class="line">    <span class="built_in">NSNumber</span> *minValue = [array valueForKeyPath:<span class="string">@"@min.self"</span>];</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"minValue - %@"</span>, minValue); <span class="comment">// minValue - 0.31</span></div><div class="line">    </div><div class="line">    <span class="built_in">NSInteger</span> index = [array indexOfObject:minValue];</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"index - %lu"</span>, index); <span class="comment">// index - 1</span></div><div class="line">    <span class="comment">// 从输出可以看到当有重复值时，获取的index是在靠前位置的</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;UIScrollview上的UIPangesturerecognizer冲突&quot;&gt;&lt;a href=&quot;#UIScrollview上的UIPangesturerecognizer冲突&quot; class=&quot;headerlink&quot; title=&quot;UIScrollview上的UIPangesturerecognizer冲突&quot;&gt;&lt;/a&gt;UIScrollview上的UIPangesturerecognizer冲突&lt;/h2&gt;&lt;p&gt;在tableview里的cell的imageview上加个UIPangesturerecognizer会发现优先滚动imageview，tableView不响应滚动了，原因是tableview的实现也是用了UIPangesturerecognizer。解决方案如下：&lt;br&gt;&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 实现 UIGestureRecognizerDelegate&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;- (&lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt;)gestureRecognizer:(&lt;span class=&quot;built_in&quot;&gt;UIGestureRecognizer&lt;/span&gt; *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(&lt;span class=&quot;built_in&quot;&gt;UIGestureRecognizer&lt;/span&gt; *)otherGestureRecognizer &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;YES&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://note.snail-z.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="iOS" scheme="http://note.snail-z.me/tags/iOS/"/>
    
      <category term="Objective-C" scheme="http://note.snail-z.me/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>iOS AutoLayout之 - NSLayoutConstraint</title>
    <link href="http://note.snail-z.me/2017/03/19/iOS%20AutoLayout%E4%B9%8B%20-%20NSLayoutConstraint/"/>
    <id>http://note.snail-z.me/2017/03/19/iOS AutoLayout之 - NSLayoutConstraint/</id>
    <published>2017-03-19T08:15:03.000Z</published>
    <updated>2017-03-25T04:31:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>AutoLayout是在iOS6之后推出的一种基于约束的，描述性的布局系统。使用约束条件来定义view的位置和尺寸。解决了不同分辨率和屏幕尺寸下view的适配问题，也简化了旋转时view位置的定义。<br>之前一直使用frame或第三方库<a href="https://github.com/SnapKit/Masonry.git" target="_blank" rel="external">Masonry</a>布局，对约束如何实现的并不清楚，所以抽时间进行了简单学习，并记录下如何使用纯代码NSLayoutConstraint实现autoLayout。<br><a id="more"></a></p>
<h3 id="显式创建约束方法constraintWithItem"><a href="#显式创建约束方法constraintWithItem" class="headerlink" title="显式创建约束方法constraintWithItem"></a>显式创建约束方法constraintWithItem</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">+(<span class="keyword">instancetype</span>)constraintWithItem:(<span class="keyword">id</span>)view1</div><div class="line">                        attribute:(<span class="built_in">NSLayoutAttribute</span>)attr1</div><div class="line">                        relatedBy:(<span class="built_in">NSLayoutRelation</span>)relation</div><div class="line">                           toItem:(<span class="keyword">nullable</span> <span class="keyword">id</span>)view2</div><div class="line">                        attribute:(<span class="built_in">NSLayoutAttribute</span>)attr2</div><div class="line">                       multiplier:(<span class="built_in">CGFloat</span>)multiplier</div><div class="line">                         constant:(<span class="built_in">CGFloat</span>)constant;</div></pre></td></tr></table></figure>
<ul>
<li><code>view1</code>：要添加约束的视图</li>
<li><code>attr1</code>：约束枚举<code>NSLayoutAttribute</code></li>
<li><code>relation</code>：与约束值的关系，大于 等于或小于</li>
<li><code>view2</code>：被参照对象</li>
<li><code>attr2</code>：被参照对象所被参照的枚举值<code>NSLayoutAttribute</code></li>
<li><code>multiplier</code>：乘数，确定间距倍数等关系（默认1.0） </li>
<li><code>constant</code>：差值常量<blockquote>
<p>注：view1与view2的位置和大小约束关系满足表达式:<br><code>view1.attr1 = view2.attr2 * multiplier + constant</code></p>
</blockquote>
</li>
</ul>
<p>简单介绍下NSLayoutAttribute的枚举值：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSLayoutAttributeLeft</span>：          <span class="comment">// 视图的x坐标，相当于CGRectGetMinX(view.frame)</span></div><div class="line"><span class="built_in">NSLayoutAttributeRight</span>：         <span class="comment">// CGRectGetMaxX(view.frame);</span></div><div class="line"><span class="built_in">NSLayoutAttributeTop</span>：           <span class="comment">// CGRectGetMinY(view.frame);</span></div><div class="line"><span class="built_in">NSLayoutAttributeBottom</span>：        <span class="comment">// CGRectGetMinY(view.frame);</span></div><div class="line"><span class="built_in">NSLayoutAttributeWidth</span>：         <span class="comment">// 视图宽度</span></div><div class="line"><span class="built_in">NSLayoutAttributeHeight</span>：        <span class="comment">// 视图高度</span></div><div class="line"><span class="built_in">NSLayoutAttributeCenterX</span>：       <span class="comment">// 视图中点的X值</span></div><div class="line"><span class="built_in">NSLayoutAttributeCenterY</span>：       <span class="comment">// 视图中点的Y值;</span></div><div class="line"><span class="built_in">NSLayoutAttributeBaseline</span>：      <span class="comment">// 视图的基准线</span></div><div class="line"><span class="built_in">NSLayoutAttributeLastBaseline</span>：  <span class="comment">// 相当于NSLayoutAttributeBaseline;</span></div><div class="line"><span class="built_in">NSLayoutAttributeFirstBaseline</span>： <span class="comment">// 文本上标线;</span></div><div class="line"><span class="built_in">NSLayoutAttributeNotAnAttribute</span>：<span class="comment">// None;</span></div><div class="line"></div><div class="line"><span class="built_in">NSLayoutAttributeLeading</span>： <span class="comment">// 在习惯由左向右看的地区，相当于NSLayoutAttributeLeft；在习惯从右至左看的地区，相当于NSLayoutAttributeRight;</span></div><div class="line"><span class="built_in">NSLayoutAttributeTrailing</span>：<span class="comment">// 在习惯由左向右看的地区，相当于NSLayoutAttributeRight；在习惯从右至左看的地区，相当于NSLayoutAttributeLeft;</span></div><div class="line"></div><div class="line"><span class="comment">// 以下iOS8新增属性，各种间距，网络查阅不少文章也没具体介绍，暂时我也不清楚，有时间会再详细测试。</span></div><div class="line"><span class="built_in">NSLayoutAttributeLeftMargin</span></div><div class="line"><span class="built_in">NSLayoutAttributeRightMargin</span></div><div class="line"><span class="built_in">NSLayoutAttributeTopMargin</span></div><div class="line"><span class="built_in">NSLayoutAttributeBottomMargin</span></div><div class="line"><span class="built_in">NSLayoutAttributeLeadingMargin</span></div><div class="line"><span class="built_in">NSLayoutAttributeTrailingMargin</span></div><div class="line"><span class="built_in">NSLayoutAttributeCenterXWithinMargins</span></div><div class="line"><span class="built_in">NSLayoutAttributeCenterYWithinMargins</span></div></pre></td></tr></table></figure></p>
<p>下面通过代码来了解constraintWithItem这个方法：</p>
<blockquote>
<p>注: 使用<code>Auto Layout</code>时，必须先将视图的<code>translatesAutoresizingMaskIntoConstraints</code>属性设为NO。因为当它为YES时，自己添加的约束会与系统的<code>Autoresizing Mask</code>约束产生冲突。</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建两个视图view1和view2</span></div><div class="line"><span class="built_in">UIView</span> *view1 = [[<span class="built_in">UIView</span> alloc] init];</div><div class="line">view1.backgroundColor = [<span class="built_in">UIColor</span> brownColor];</div><div class="line">[<span class="keyword">self</span>.view addSubview:view1];</div><div class="line"><span class="comment">// 不需要给view设置frame</span></div><div class="line"></div><div class="line"><span class="built_in">UIView</span> *view2 = [[<span class="built_in">UIView</span> alloc] init];</div><div class="line">view2.backgroundColor = [<span class="built_in">UIColor</span> orangeColor];</div><div class="line">[<span class="keyword">self</span>.view addSubview:view2];</div><div class="line"></div><div class="line"><span class="comment">// 关掉AutoresizingMask布局</span></div><div class="line">view1.translatesAutoresizingMaskIntoConstraints = <span class="literal">NO</span>;</div><div class="line">view2.translatesAutoresizingMaskIntoConstraints = <span class="literal">NO</span>;</div><div class="line"> </div><div class="line"><span class="comment">// view1：设置宽度为100px</span></div><div class="line">[<span class="keyword">self</span>.view addConstraint:[<span class="built_in">NSLayoutConstraint</span> constraintWithItem:view1</div><div class="line">                                                      attribute:<span class="built_in">NSLayoutAttributeWidth</span></div><div class="line">                                                      relatedBy:<span class="built_in">NSLayoutRelationEqual</span></div><div class="line">                                                         toItem:<span class="literal">nil</span></div><div class="line">                                                      attribute:<span class="built_in">NSLayoutAttributeNotAnAttribute</span></div><div class="line">                                                     multiplier:<span class="number">1</span></div><div class="line">                                                       constant:<span class="number">100</span>]];</div><div class="line"><span class="comment">// 如果是设置view自身的属性，不涉及到与其他view的位置约束关系时。constraintWithItem:方法的toItem参数应设为nil；且第五个参数attribute应设为NSLayoutAttributeNotAnAttribute </span></div><div class="line"><span class="comment">// 约束一定要添加在父视图上</span></div><div class="line"></div><div class="line"><span class="comment">// view1：设置高度等于宽度</span></div><div class="line">[<span class="keyword">self</span>.view addConstraint:[<span class="built_in">NSLayoutConstraint</span> constraintWithItem:view1</div><div class="line">                                                     attribute:<span class="built_in">NSLayoutAttributeHeight</span></div><div class="line">                                                     relatedBy:<span class="built_in">NSLayoutRelationEqual</span></div><div class="line">                                                        toItem:view1</div><div class="line">                                                     attribute:<span class="built_in">NSLayoutAttributeWidth</span></div><div class="line">                                                    multiplier:<span class="number">1</span></div><div class="line">                                                      constant:<span class="number">0</span>]];</div><div class="line"></div><div class="line"><span class="comment">// view1：设置在父视图水平方向上居中</span></div><div class="line">[<span class="keyword">self</span>.view addConstraint:[<span class="built_in">NSLayoutConstraint</span> constraintWithItem:view1</div><div class="line">                                                      attribute:<span class="built_in">NSLayoutAttributeCenterX</span></div><div class="line">                                                      relatedBy:<span class="built_in">NSLayoutRelationEqual</span></div><div class="line">                                                         toItem:<span class="keyword">self</span>.view</div><div class="line">                                                      attribute:<span class="built_in">NSLayoutAttributeCenterX</span></div><div class="line">                                                     multiplier:<span class="number">1</span></div><div class="line">                                                       constant:<span class="number">0</span>]];</div><div class="line"><span class="comment">// view1：设置在垂直方向上始终距离父视图底部为50px</span></div><div class="line">[<span class="keyword">self</span>.view addConstraint:[<span class="built_in">NSLayoutConstraint</span> constraintWithItem:view1</div><div class="line">                                                      attribute:<span class="built_in">NSLayoutAttributeBottom</span></div><div class="line">                                                      relatedBy:<span class="built_in">NSLayoutRelationEqual</span></div><div class="line">                                                         toItem:<span class="keyword">self</span>.view</div><div class="line">                                                      attribute:<span class="built_in">NSLayoutAttributeBottom</span></div><div class="line">                                                     multiplier:<span class="number">1</span></div><div class="line">                                                       constant:<span class="number">-50</span>]]; <span class="comment">// 类似的Bottom、Right设置为负</span></div><div class="line"></div><div class="line"><span class="comment">// view2：设置宽度是view1宽度的0.5倍</span></div><div class="line">[<span class="keyword">self</span>.view addConstraint:[<span class="built_in">NSLayoutConstraint</span> constraintWithItem:view2</div><div class="line">                                                      attribute:<span class="built_in">NSLayoutAttributeWidth</span></div><div class="line">                                                      relatedBy:<span class="built_in">NSLayoutRelationEqual</span></div><div class="line">                                                         toItem:view1</div><div class="line">                                                      attribute:<span class="built_in">NSLayoutAttributeWidth</span></div><div class="line">                                                     multiplier:<span class="number">0.5</span></div><div class="line">                                                       constant:<span class="number">0</span>]];</div><div class="line"></div><div class="line"><span class="comment">// view2：设置垂直方向上距父视图顶部100px</span></div><div class="line">[<span class="keyword">self</span>.view addConstraint:[<span class="built_in">NSLayoutConstraint</span> constraintWithItem:view2</div><div class="line">                                                      attribute:<span class="built_in">NSLayoutAttributeTop</span></div><div class="line">                                                      relatedBy:<span class="built_in">NSLayoutRelationEqual</span></div><div class="line">                                                         toItem:<span class="keyword">self</span>.view</div><div class="line">                                                      attribute:<span class="built_in">NSLayoutAttributeTop</span></div><div class="line">                                                     multiplier:<span class="number">1</span></div><div class="line">                                                       constant:<span class="number">100</span>]];</div><div class="line"></div><div class="line"><span class="comment">// view2：设置垂直方向上距view1顶部50px</span></div><div class="line">[<span class="keyword">self</span>.view addConstraint:[<span class="built_in">NSLayoutConstraint</span> constraintWithItem:view2</div><div class="line">                                                      attribute:<span class="built_in">NSLayoutAttributeBottom</span></div><div class="line">                                                      relatedBy:<span class="built_in">NSLayoutRelationEqual</span></div><div class="line">                                                         toItem:view1</div><div class="line">                                                      attribute:<span class="built_in">NSLayoutAttributeTop</span></div><div class="line">                                                     multiplier:<span class="number">1</span></div><div class="line">                                                       constant:<span class="number">-50</span>]];</div><div class="line"><span class="comment">// 通过以上两个条件可以确定高度，所以不需要再设置高度。</span></div><div class="line"></div><div class="line"><span class="comment">//view2：最后设置水平方向上距离父视图的左边间距与距离view1的间距相等</span></div><div class="line">[<span class="keyword">self</span>.view addConstraint:[<span class="built_in">NSLayoutConstraint</span> constraintWithItem:view2</div><div class="line">                                                      attribute:<span class="built_in">NSLayoutAttributeCenterX</span></div><div class="line">                                                      relatedBy:<span class="built_in">NSLayoutRelationEqual</span></div><div class="line">                                                         toItem:view1</div><div class="line">                                                      attribute:<span class="built_in">NSLayoutAttributeLeft</span></div><div class="line">                                                     multiplier:<span class="number">0.5</span></div><div class="line">                                                       constant:<span class="number">0</span>]];</div></pre></td></tr></table></figure>
<p>运行程序查看效果，也可以大致参考下图的简单说明：</p>
<p><img src="https://github.com/snail-z/snail-z.github.io/blob/master/images/constraint1.png?raw=true" alt="image"></p>
<hr>
<h3 id="使用VFL-即Visual-Format-Language-可视化格式语言创建约束"><a href="#使用VFL-即Visual-Format-Language-可视化格式语言创建约束" class="headerlink" title="使用VFL(即Visual Format Language)可视化格式语言创建约束"></a>使用VFL(即Visual Format Language)可视化格式语言创建约束</h3><p>VFL的API<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">NSArray</span>&lt;<span class="built_in">NSLayoutConstraint</span> *&gt; *)constraintsWithVisualFormat:(<span class="built_in">NSString</span> *)format</div><div class="line">                                                       options:(<span class="built_in">NSLayoutFormatOptions</span>)opts</div><div class="line">                                                       metrics:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *,<span class="keyword">id</span>&gt; *)metrics</div><div class="line">                                                         views:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)views;</div></pre></td></tr></table></figure></p>
<ul>
<li><code>format</code>：VFL格式字符串</li>
<li><code>opts</code>： 对齐方式的枚举值<code>NSLayoutFormatOptions</code></li>
<li><code>metrics</code>：设置需要进行替换的值，是字典类型，通过下面代码加以理解</li>
<li><code>views</code>：传入约束中用到的views，也是字典类型。注意字典中的values一定要和format参数里所写的views名字相同</li>
</ul>
<p>部分NSLayoutFormatOptions的枚举值介绍：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSLayoutFormatAlignAllLeft</span> = (<span class="number">1</span> &lt;&lt; <span class="built_in">NSLayoutAttributeLeft</span>)：      <span class="comment">// 左边对齐</span></div><div class="line"><span class="built_in">NSLayoutFormatAlignAllRight</span> = (<span class="number">1</span> &lt;&lt; <span class="built_in">NSLayoutAttributeRight</span>)：    <span class="comment">// 右边对齐</span></div><div class="line"><span class="built_in">NSLayoutFormatAlignAllTop</span> = (<span class="number">1</span> &lt;&lt; <span class="built_in">NSLayoutAttributeTop</span>)：        <span class="comment">// 顶部对齐</span></div><div class="line"><span class="built_in">NSLayoutFormatAlignAllBottom</span> = (<span class="number">1</span> &lt;&lt; <span class="built_in">NSLayoutAttributeBottom</span>)：  <span class="comment">// 底部对齐</span></div><div class="line"><span class="built_in">NSLayoutFormatAlignAllCenterX</span> = (<span class="number">1</span> &lt;&lt; <span class="built_in">NSLayoutAttributeCenterX</span>)：<span class="comment">// 垂直方向中心对齐</span></div><div class="line"><span class="built_in">NSLayoutFormatAlignAllCenterY</span> = (<span class="number">1</span> &lt;&lt; <span class="built_in">NSLayoutAttributeCenterY</span>)：<span class="comment">// 水平方向中心对齐</span></div></pre></td></tr></table></figure></p>
<p>下面通过代码来了解constraintsWithVisualFormat这个方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建视图</span></div><div class="line"><span class="built_in">UIView</span> *view1 = [[<span class="built_in">UIView</span> alloc] init];</div><div class="line">view1.backgroundColor = [<span class="built_in">UIColor</span> brownColor];</div><div class="line">[<span class="keyword">self</span>.view addSubview:view1];</div><div class="line"></div><div class="line"><span class="comment">// 关掉AutoresizingMask</span></div><div class="line">view1.translatesAutoresizingMaskIntoConstraints = <span class="literal">NO</span>;</div><div class="line"></div><div class="line"><span class="comment">// ①</span></div><div class="line"><span class="built_in">NSDictionary</span> *viewsDict = <span class="built_in">NSDictionaryOfVariableBindings</span>(view1);</div><div class="line"></div><div class="line"><span class="comment">// ②</span></div><div class="line"><span class="built_in">NSArray</span> *constraints1 = [<span class="built_in">NSLayoutConstraint</span> constraintsWithVisualFormat:<span class="string">@"H:|-[view1]-50-|"</span></div><div class="line">                                                                options:<span class="number">0</span></div><div class="line">                                                                metrics:<span class="literal">nil</span></div><div class="line">                                                                  views:viewsDict];</div><div class="line"></div><div class="line"><span class="comment">// ③</span></div><div class="line"><span class="built_in">NSArray</span> *constraints2 = [<span class="built_in">NSLayoutConstraint</span> constraintsWithVisualFormat:<span class="string">@"V:|-100-[view1(==200)]"</span></div><div class="line">                                                                options:<span class="number">0</span></div><div class="line">                                                                metrics:<span class="literal">nil</span></div><div class="line">                                                                  views:viewsDict];</div><div class="line"></div><div class="line"><span class="comment">// 使用addConstraints添加约束</span></div><div class="line">[<span class="keyword">self</span>.view addConstraints:constraints1];</div><div class="line">[<span class="keyword">self</span>.view addConstraints:constraints2];</div></pre></td></tr></table></figure>
<p>下面介绍上面代码中的标记：<br>① <code>NSDictionaryOfVariableBindings(view1)</code>：<br>    这是个宏定义，字典格式可以理解为 <code>@{ @&quot;view1&quot; : @&quot;view1&quot;};</code> 相当于将key - value进行对应绑定；因为在VFL中是通过key来寻找对应的value。比如<code>@{@&quot;aView&quot; : @&quot;self.sView&quot;}</code>它会布局self.sView而不是aView。所以你在VFL中看到的变量是key，而不是value。</p>
<blockquote>
<p>注：在format字符串里或是在binding字典里，都应该避免使用类似self.view1这样的字样，可以使用<code>_view1</code>。</p>
</blockquote>
<p>② <code>@&quot;H:|-[view1]-50-|&quot;</code> ：<br>    <code>H:</code> 表示在水平方向上添加约束（H即horizontal）；<br>    <code>|</code> 是表示父视图；<br>    <code>-</code> 表示一个间距；如果未设置间距值，当和父视图之间时，默认代表20px（可看作-20-），如果是两个同级别的view，比如<code>@&quot;[view1]-[view2]&quot;</code>，则表示8px；<br>    所以这句话可理解为view1在水平方向上距父视图左边20px，距离父视图右边50px</p>
<p>③ <code>@&quot;V:|-100-[view1(==200)]&quot;</code> ：<br>    <code>V:</code> 表示在垂直方向上添加约束（V即vertical）；<br>    <code>[view1(==200)]</code> 如果是在垂直方向上则表示view1的高度等200，水平方向则表示宽等某个值，可省略<code>==</code> 简化为<code>[view1(200)]</code>；<br>    由于确定了高度，所以底部间距不用设置，不然会起冲突。所以这句话可理解为view1在垂直方向上距父视图顶部100px，高为200px</p>
<p>再通过一个例子加深理解：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UIView</span> *sView = [[<span class="built_in">UIView</span> alloc] init];</div><div class="line">sView.backgroundColor = [<span class="built_in">UIColor</span> darkGrayColor];</div><div class="line">[<span class="keyword">self</span>.view addSubview:sView];</div><div class="line"></div><div class="line"><span class="built_in">UIView</span> *view1 = [[<span class="built_in">UIView</span> alloc] init];</div><div class="line">view1.backgroundColor = [<span class="built_in">UIColor</span> brownColor];</div><div class="line">[sView addSubview:view1];</div><div class="line"></div><div class="line"><span class="built_in">UIView</span> *view2 = [[<span class="built_in">UIView</span> alloc] init];</div><div class="line">view2.backgroundColor = [<span class="built_in">UIColor</span> orangeColor];</div><div class="line">[sView addSubview:view2]; <span class="comment">// 将view1 view2添加到sView上</span></div><div class="line"></div><div class="line"><span class="comment">// 关掉AutoresizingMask布局</span></div><div class="line">sView.translatesAutoresizingMaskIntoConstraints = <span class="literal">NO</span>;</div><div class="line">view1.translatesAutoresizingMaskIntoConstraints = <span class="literal">NO</span>;</div><div class="line">view2.translatesAutoresizingMaskIntoConstraints = <span class="literal">NO</span>;</div><div class="line"></div><div class="line"><span class="built_in">NSDictionary</span> *viewsDict = <span class="built_in">NSDictionaryOfVariableBindings</span>(sView, view1, view2);</div><div class="line"></div><div class="line"><span class="comment">// 设置间距和宽度要进行替换的值</span></div><div class="line"><span class="built_in">NSDictionary</span> *metricsDict = @&#123;<span class="string">@"padding"</span> : @<span class="number">50</span>, <span class="string">@"height"</span> : @<span class="number">150</span>&#125;;</div><div class="line"></div><div class="line"><span class="comment">// sView：水平方向布局</span></div><div class="line"><span class="built_in">NSArray</span> *constraints1 = [<span class="built_in">NSLayoutConstraint</span> constraintsWithVisualFormat:<span class="string">@"H:|-padding-[sView]-padding-|"</span></div><div class="line">                                                                options:kNilOptions</div><div class="line">                                                                metrics:metricsDict</div><div class="line">                                                                  views:viewsDict];</div><div class="line"></div><div class="line"><span class="comment">// sView：垂直方向布局</span></div><div class="line"><span class="built_in">NSArray</span> *constraints2 = [<span class="built_in">NSLayoutConstraint</span> constraintsWithVisualFormat:<span class="string">@"V:[sView(height)]-padding-|"</span></div><div class="line">                                                                options:kNilOptions</div><div class="line">                                                                metrics:metricsDict</div><div class="line">                                                                  views:viewsDict];</div><div class="line"></div><div class="line"><span class="comment">// 使用addConstraints添加约束</span></div><div class="line">[<span class="keyword">self</span>.view addConstraints:constraints1];</div><div class="line">[<span class="keyword">self</span>.view addConstraints:constraints2];</div><div class="line"></div><div class="line"><span class="comment">// view1 - view2：水平方向布局</span></div><div class="line"><span class="comment">// 设置对齐方式，view2顶部与底部都与view1对齐</span></div><div class="line"><span class="built_in">NSLayoutFormatOptions</span> options = <span class="built_in">NSLayoutFormatAlignAllTop</span> | <span class="built_in">NSLayoutFormatAlignAllBottom</span>;</div><div class="line"></div><div class="line"><span class="built_in">NSArray</span> *constraints3 = [<span class="built_in">NSLayoutConstraint</span> constraintsWithVisualFormat:<span class="string">@"H:|-15-[view1(100)]-padding-[view2]-15-|"</span></div><div class="line">                                                                options:options</div><div class="line">                                                                metrics:metricsDict</div><div class="line">                                                                  views:viewsDict];</div><div class="line"></div><div class="line"><span class="comment">// view1：垂直方向布局，根据设置的对齐方式可以确定view2高度与view1相等，所以不需要再进行对view2垂直方向上的布局</span></div><div class="line"><span class="built_in">NSArray</span> *constraints4 = [<span class="built_in">NSLayoutConstraint</span> constraintsWithVisualFormat:<span class="string">@"V:|-15-[view1]-15-|"</span></div><div class="line">                                                                options:kNilOptions</div><div class="line">                                                                metrics:metricsDict</div><div class="line">                                                                  views:viewsDict];</div><div class="line"></div><div class="line">[sView addConstraints:constraints3];</div><div class="line">[sView addConstraints:constraints4];</div><div class="line"></div><div class="line"><span class="comment">// 继续创建一个视图redView</span></div><div class="line"><span class="built_in">UIView</span> *redView = [[<span class="built_in">UIView</span> alloc] init];</div><div class="line">redView.backgroundColor = [<span class="built_in">UIColor</span> redColor];</div><div class="line">redView.translatesAutoresizingMaskIntoConstraints = <span class="literal">NO</span>;</div><div class="line">[<span class="keyword">self</span>.view addSubview:redView];</div><div class="line"></div><div class="line"><span class="comment">// 设置redView的左右两端对齐sView且高度等于sView的高</span></div><div class="line"><span class="built_in">NSArray</span> *constraints5 = [<span class="built_in">NSLayoutConstraint</span></div><div class="line">                        constraintsWithVisualFormat:<span class="string">@"V:[redView(sView)]-15-[sView]"</span></div><div class="line">                        options:<span class="built_in">NSLayoutFormatAlignAllLeft</span> | <span class="built_in">NSLayoutFormatAlignAllRight</span></div><div class="line">                        metrics:<span class="literal">nil</span></div><div class="line">                        views:<span class="built_in">NSDictionaryOfVariableBindings</span>(sView, redView)];</div><div class="line"></div><div class="line">[<span class="keyword">self</span>.view addConstraints:constraints5];</div></pre></td></tr></table></figure></p>
<p>查看运行效果，大致如下：</p>
<p><img src="https://github.com/snail-z/snail-z.github.io/blob/master/images/constraint2.png?raw=true" alt="image"></p>
<hr>
<h3 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h3><ul>
<li>假如设置三个视图的宽高固定为50px，如何让三个视图在垂直方向上居中且等分所有间距？</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 简单将宽高的约束进行封装</span></div><div class="line">- (<span class="built_in">NSArray</span>&lt;<span class="built_in">NSLayoutConstraint</span> *&gt; *)constraintSize:(<span class="built_in">CGSize</span>)size forView:(<span class="built_in">UIView</span> *)view &#123;</div><div class="line">    </div><div class="line">    <span class="built_in">NSLayoutConstraint</span> *constraintWidth = [<span class="built_in">NSLayoutConstraint</span></div><div class="line">                                           constraintWithItem:view</div><div class="line">                                           attribute:<span class="built_in">NSLayoutAttributeWidth</span></div><div class="line">                                           relatedBy:<span class="built_in">NSLayoutRelationEqual</span></div><div class="line">                                           toItem:<span class="literal">nil</span></div><div class="line">                                           attribute:<span class="built_in">NSLayoutAttributeNotAnAttribute</span></div><div class="line">                                           multiplier:<span class="number">1</span></div><div class="line">                                           constant:size.width];</div><div class="line">    </div><div class="line">    <span class="built_in">NSLayoutConstraint</span> *constraintHeight = [<span class="built_in">NSLayoutConstraint</span></div><div class="line">                                            constraintWithItem:view</div><div class="line">                                            attribute:<span class="built_in">NSLayoutAttributeHeight</span></div><div class="line">                                            relatedBy:<span class="built_in">NSLayoutRelationEqual</span></div><div class="line">                                            toItem:<span class="literal">nil</span></div><div class="line">                                            attribute:<span class="built_in">NSLayoutAttributeNotAnAttribute</span></div><div class="line">                                            multiplier:<span class="number">1</span></div><div class="line">                                            constant:size.height];</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> @[constraintWidth, constraintHeight];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 简单的将constraintWithItem方法简化封装</span></div><div class="line">- (<span class="built_in">NSLayoutConstraint</span> *)constraintView:(<span class="built_in">UIView</span> *)item</div><div class="line">                             attribute:(<span class="built_in">NSLayoutAttribute</span>)attr1</div><div class="line">                                toView:(<span class="built_in">UIView</span> *)toView</div><div class="line">                             attribute:(<span class="built_in">NSLayoutAttribute</span>)attr2 &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> [<span class="built_in">NSLayoutConstraint</span> constraintWithItem:item</div><div class="line">                                        attribute:attr1</div><div class="line">                                        relatedBy:<span class="built_in">NSLayoutRelationEqual</span></div><div class="line">                                           toItem:toView</div><div class="line">                                        attribute:attr2</div><div class="line">                                       multiplier:<span class="number">1</span></div><div class="line">                                         constant:<span class="number">0</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>思路：因为是三个视图，所以会等分四个间距，可以通过辅助视图来填充间距，且每个辅助视图的宽是相等的，然后和固定的三个视图的宽的总和等于父视图的宽。详细参考下面代码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 设置三个视图的宽高固定为50px，让三个视图在垂直方向上居中且等分所有间距。</span></div><div class="line">- (<span class="keyword">void</span>)example7 &#123;</div><div class="line">  <span class="built_in">NSInteger</span> N = <span class="number">3</span>;</div><div class="line">  <span class="built_in">CGSize</span> _size = <span class="built_in">CGSizeMake</span>(<span class="number">50</span>, <span class="number">50</span>);</div><div class="line"></div><div class="line">  <span class="comment">// 创建第一个辅助视图，也是用它来保存上一个辅助视图</span></div><div class="line">  <span class="built_in">UIView</span> *lastHelperView = [<span class="built_in">UIView</span> new];</div><div class="line">  lastHelperView.backgroundColor = [<span class="built_in">UIColor</span> darkGrayColor];</div><div class="line">  [<span class="keyword">self</span>.view addSubview:lastHelperView];</div><div class="line">  lastHelperView.translatesAutoresizingMaskIntoConstraints = <span class="literal">NO</span>;</div><div class="line"></div><div class="line">   <span class="comment">// 添加上边约束</span></div><div class="line">    [<span class="keyword">self</span>.view addConstraint:[<span class="keyword">self</span> constraintView:lastHelperView</div><div class="line">                                        attribute:<span class="built_in">NSLayoutAttributeTop</span></div><div class="line">                                           toView:<span class="keyword">self</span>.view</div><div class="line">                                        attribute:<span class="built_in">NSLayoutAttributeTop</span>]];</div><div class="line">    <span class="comment">// 下</span></div><div class="line">    [<span class="keyword">self</span>.view addConstraint:[<span class="keyword">self</span> constraintView:lastHelperView</div><div class="line">                                        attribute:<span class="built_in">NSLayoutAttributeBottom</span></div><div class="line">                                           toView:<span class="keyword">self</span>.view</div><div class="line">                                        attribute:<span class="built_in">NSLayoutAttributeBottom</span>]];</div><div class="line">    <span class="comment">// 左</span></div><div class="line">    [<span class="keyword">self</span>.view addConstraint:[<span class="keyword">self</span> constraintView:lastHelperView</div><div class="line">                                        attribute:<span class="built_in">NSLayoutAttributeLeft</span></div><div class="line">                                           toView:<span class="keyword">self</span>.view</div><div class="line">                                        attribute:<span class="built_in">NSLayoutAttributeLeft</span>]];</div><div class="line">  <span class="comment">// 循环创建</span></div><div class="line">  <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</div><div class="line">        </div><div class="line">        <span class="built_in">UIView</span> *view = [<span class="built_in">UIView</span> new];</div><div class="line">        view.backgroundColor = [<span class="built_in">UIColor</span> orangeColor];</div><div class="line">        view.translatesAutoresizingMaskIntoConstraints = <span class="literal">NO</span>;</div><div class="line">        [<span class="keyword">self</span>.view addSubview:view];</div><div class="line">        </div><div class="line">        <span class="comment">// 固定view宽高为50px</span></div><div class="line">        [<span class="keyword">self</span>.view addConstraints:[<span class="keyword">self</span> constraintSize:_size forView:view]];</div><div class="line">        <span class="comment">// CenterY居中</span></div><div class="line">        [<span class="keyword">self</span>.view addConstraint:[<span class="keyword">self</span> constraintView:view</div><div class="line">                                            attribute:<span class="built_in">NSLayoutAttributeCenterY</span></div><div class="line">                                               toView:<span class="keyword">self</span>.view</div><div class="line">                                            attribute:<span class="built_in">NSLayoutAttributeCenterY</span>]];</div><div class="line">        <span class="comment">// 左边约束</span></div><div class="line">        [<span class="keyword">self</span>.view addConstraint:[<span class="keyword">self</span> constraintView:view</div><div class="line">                                            attribute:<span class="built_in">NSLayoutAttributeLeft</span></div><div class="line">                                               toView:lastHelperView</div><div class="line">                                            attribute:<span class="built_in">NSLayoutAttributeRight</span>]];</div><div class="line">        </div><div class="line">        <span class="built_in">UIView</span> *helperView = [<span class="built_in">UIView</span> new];</div><div class="line">        helperView.backgroundColor = [<span class="built_in">UIColor</span> darkGrayColor];</div><div class="line">        [<span class="keyword">self</span>.view addSubview:helperView];</div><div class="line">        helperView.translatesAutoresizingMaskIntoConstraints = <span class="literal">NO</span>;</div><div class="line">        <span class="comment">// 上</span></div><div class="line">        [<span class="keyword">self</span>.view addConstraint:[<span class="keyword">self</span> constraintView:helperView</div><div class="line">                                            attribute:<span class="built_in">NSLayoutAttributeTop</span></div><div class="line">                                               toView:<span class="keyword">self</span>.view</div><div class="line">                                            attribute:<span class="built_in">NSLayoutAttributeTop</span>]];</div><div class="line">        <span class="comment">// 下</span></div><div class="line">        [<span class="keyword">self</span>.view addConstraint:[<span class="keyword">self</span> constraintView:helperView</div><div class="line">                                            attribute:<span class="built_in">NSLayoutAttributeBottom</span></div><div class="line">                                               toView:<span class="keyword">self</span>.view</div><div class="line">                                            attribute:<span class="built_in">NSLayoutAttributeBottom</span>]];</div><div class="line">        <span class="comment">// 等间距约束（即等宽）</span></div><div class="line">        [<span class="keyword">self</span>.view addConstraint:[<span class="keyword">self</span> constraintView:helperView</div><div class="line">                                            attribute:<span class="built_in">NSLayoutAttributeWidth</span></div><div class="line">                                               toView:lastHelperView</div><div class="line">                                            attribute:<span class="built_in">NSLayoutAttributeWidth</span>]];</div><div class="line">        <span class="comment">// 左</span></div><div class="line">        [<span class="keyword">self</span>.view addConstraint:[<span class="keyword">self</span> constraintView:helperView</div><div class="line">                                            attribute:<span class="built_in">NSLayoutAttributeLeft</span></div><div class="line">                                               toView:view</div><div class="line">                                            attribute:<span class="built_in">NSLayoutAttributeRight</span>]];</div><div class="line">        lastHelperView = helperView;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 为最后一个helperView添加右边约束</span></div><div class="line">    [<span class="keyword">self</span>.view addConstraint:[<span class="keyword">self</span> constraintView:lastHelperView</div><div class="line">                                        attribute:<span class="built_in">NSLayoutAttributeRight</span></div><div class="line">                                           toView:<span class="keyword">self</span>.view</div><div class="line">                                        attribute:<span class="built_in">NSLayoutAttributeRight</span>]];</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行查看效果：<br><img src="https://github.com/snail-z/snail-z.github.io/blob/master/images/constraint3.png?raw=true" alt="image"></p>
<p>以上就是对NSLayoutConstraint学习做的笔记和遇到的问题，后期会在进行深入理解研究~~<br>本文<a href="https://github.com/snail-z/blog-demos.git" target="_blank" rel="external">Demo</a>已经上传至github，在里面的AutoLayout-Notes目录下。</p>
<hr>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="http://adad184.com/2014/09/28/use-masonry-to-quick-solve-autolayout/" target="_blank" rel="external">Masonry介绍与使用实践(快速上手Autolayout)</a></li>
<li><a href="http://tutuge.me/2015/12/14/autolayout-example-with-masonry3/" target="_blank" rel="external">有趣的Autolayout示例三-Masonry实现</a></li>
<li><a href="http://jinqianchina.github.io/2016/04/29/iOS%E5%BC%80%E5%8F%91-%E8%87%AA%E5%8A%A8%E5%B8%83%E5%B1%80%E7%AF%87%EF%BC%9A%E5%8F%B2%E4%B8%8A%E6%9C%80%E7%89%9B%E7%9A%84%E8%87%AA%E5%8A%A8%E5%B8%83%E5%B1%80%E6%95%99%E5%AD%A6%EF%BC%81/" target="_blank" rel="external">iOS开发-自动布局篇</a></li>
<li><a href="http://www.jianshu.com/p/d7a4790090f1" target="_blank" rel="external">iOS Autolayout解读</a></li>
<li><a href="https://github.com/nixzhu/dev-blog/blob/master/autolayout-tips.md#tip-1" target="_blank" rel="external">AutoLayout Tips - 两个不等宽的View，彼此相邻并”共同”居中于Superview</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;AutoLayout是在iOS6之后推出的一种基于约束的，描述性的布局系统。使用约束条件来定义view的位置和尺寸。解决了不同分辨率和屏幕尺寸下view的适配问题，也简化了旋转时view位置的定义。&lt;br&gt;之前一直使用frame或第三方库&lt;a href=&quot;https://github.com/SnapKit/Masonry.git&quot;&gt;Masonry&lt;/a&gt;布局，对约束如何实现的并不清楚，所以抽时间进行了简单学习，并记录下如何使用纯代码NSLayoutConstraint实现autoLayout。&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://note.snail-z.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="iOS" scheme="http://note.snail-z.me/tags/iOS/"/>
    
      <category term="Objective-C" scheme="http://note.snail-z.me/tags/Objective-C/"/>
    
      <category term="AutoLayout" scheme="http://note.snail-z.me/tags/AutoLayout/"/>
    
  </entry>
  
  <entry>
    <title>Cocoa中的键值观察 - KVO</title>
    <link href="http://note.snail-z.me/2017/03/18/Cocoa%E4%B8%AD%E7%9A%84%E9%94%AE%E5%80%BC%E8%A7%82%E5%AF%9F%20-%20KVO/"/>
    <id>http://note.snail-z.me/2017/03/18/Cocoa中的键值观察 - KVO/</id>
    <published>2017-03-18T03:28:30.000Z</published>
    <updated>2017-03-18T08:54:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>Key-Value Observing，是iOS中的一种设计模式，用于检测对象的某些属性的实时变化情况并作出响应，这能够为我们在开发强交互、响应式应用以及实现视图和模型的双向绑定时提供大量的帮助。<br>KVO主要用于视图交互方面，比如界面的某些数据变化了，界面的显示也跟着需要变化，那就要建立数据和界面的关联。<br><a id="more"></a></p>
<h3 id="原生KVO"><a href="#原生KVO" class="headerlink" title="原生KVO"></a>原生KVO</h3><p><font color="#008B8B"> 订阅 </font>：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)addObserver:(<span class="built_in">NSObject</span> *)observer</div><div class="line">         forKeyPath:(<span class="built_in">NSString</span> *)keyPath</div><div class="line">            options:(<span class="built_in">NSKeyValueObservingOptions</span>)options</div><div class="line">            context:(<span class="keyword">void</span> *)context;</div></pre></td></tr></table></figure></p>
<ul>
<li><code>observer</code>：KVO通知的对象注册。观察者必须实现键值观察方法</li>
<li><code>keyPath</code>：关联路径，即被观察的属性。不能设置为nil</li>
<li><code>options</code>：options可选值是一个NSKeyValueObservingOptions枚举值；首先了解一个概念，即KVO响应方法有一个NSDictionary类型参数change，这个字典中会有一个与被监听属性相关的值，譬如被改变之前的值、新值等，NSDictionary中有什么值由订阅时的options值决定，options可取值如下：<ul>
<li>NSKeyValueObservingOptionNew: 指示change字典中包含新属性值；</li>
<li>NSKeyValueObservingOptionOld: 指示change字典中包含旧属性值；</li>
<li>NSKeyValueObservingOptionInitial: 相对复杂一些，NSKeyValueObserving.h文件中有详细说明，此处略过；</li>
<li>NSKeyValueObservingOptionPrior: 相对复杂一些，NSKeyValueObserving.h文件中有详细说明，此处略过；</li>
</ul>
</li>
<li><code>context</code>：需要传递给观察者的上下文信息</li>
</ul>
<p><font color="#008B8B"> 响应 </font>：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath</div><div class="line">                      ofObject:(<span class="keyword">id</span>)object</div><div class="line">                        change:(<span class="built_in">NSDictionary</span> *)change</div><div class="line">                       context:(<span class="keyword">void</span> *)context;</div></pre></td></tr></table></figure></p>
<ul>
<li><code>keyPath</code>：keyPath的类型是NSString，这导致了我们使用了错误的keyPath而不自知，譬如将<code>@&quot;contentSize&quot;</code>错误写成<code>@&quot;contentsize&quot;</code>，更好的方法是使用<code>NSStringFromSelector(SEL aSelector)</code>方法，即改为<code>NSStringFromSelector(@selector(contentSize))</code>.</li>
<li><code>object</code>：被观察者的对象</li>
<li><code>change</code>：根据上面的Options设置，给出对应的属性值</li>
<li><code>context</code>：使用 context 上下文以及其它辅助手段才能够帮助我们更加精准地确定被观测的对象。假如父类（ClassA）和子类（ClassB）都监听了同一个对象怎么办？是ClassB处理呢还是交给父类ClassA的<code>observeValueForKeyPath:ofObject:change:context:</code>处理呢？更复杂一点，如果子类的子类（设为ClassC）也监听了同一个对象，当ClassB接收到ClassC的<code>[super observeValueForKeyPath:keyPath ofObject:object change:change context:context]</code>消息时又该如何处理呢？<br>比较靠谱的做法是自己的屁股自己擦。ClassB的observe事务在ClassB中处理，怎么知道是自己的事务还是ClassC传上来的事务呢？用context参数判断！在add observer时为context参数设置一个独一无二的值即可，在responding处理时对这个context值进行检验。如此就解决了问题，但这需要靠用户（各个层级类的程序员用户）自觉遵守。</li>
</ul>
<p><font color="#008B8B"> 取消订阅 </font>：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)removeObserver:(<span class="built_in">NSObject</span> *)observer forKeyPath:(<span class="built_in">NSString</span> *)keyPath context:(<span class="keyword">void</span> *)context;</div><div class="line">- (<span class="keyword">void</span>)removeObserver:(<span class="built_in">NSObject</span> *)observer forKeyPath:(<span class="built_in">NSString</span> *)keyPath;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>注：使用KVO消息传递机制需要注意两点，①观察者必须知道被观察对象，即在同一作用域；②观察者还需要知道被观察对象的生命周期，因为在销毁发送者对象之前，需要取消观察者的注册。</p>
</blockquote>
<p>由于系统提供的API使用起来非常不优雅，使用过程也是非常麻烦需要注意很多问题：</p>
<ol>
<li>需要手动移除观察者，且移除观察者的时机必须合适；</li>
<li>注册观察者的代码和事件发生处的代码上下文不同，传递上下文是通过<code>void *</code>指针；</li>
<li>需要覆写<code>-observeValueForKeyPath:ofObject:change:context:</code>方法，比较麻烦；</li>
<li>在复杂的业务逻辑中，准确判断被观察者相对比较麻烦，有多个被观测的对象和属性时，需要在方法中写大量的 if 进行判断；</li>
</ol>
<p>如何优雅的解决呢？ - 使用 Facebook 开源的 <a href="">KVOController</a>，如下</p>
<h3 id="KVOController"><a href="#KVOController" class="headerlink" title="KVOController"></a>KVOController</h3><p><a href="https://github.com/facebook/KVOController" target="_blank" rel="external">KVOController</a>是Facebook开源的框架使用在iOS，maxOS上，是对Cocoa中KVO的封装。 提供了<code>block</code>和<code>@selector(SEL)</code>的回调操作，使用起来既简洁优雅又保证线程安全。相比原生KVO优点如下：</p>
<ol>
<li>不需要手动移除观察者；</li>
<li>实现 KVO 与事件发生处的代码上下文相同，不需要跨方法传参数；</li>
<li>使用 block 来替代方法能够减少使用的复杂度，提升使用 KVO 的体验；</li>
<li>每一个<code>keyPath</code>会对应一个属性，不需要在<code>block</code>中使用<code>if</code>判断<code>keyPath</code>（就像UIButton处理事件一样方便）；</li>
</ol>
<p>使用<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Model *model = [[Model alloc] init];</div><div class="line">model.name = <span class="string">@"snail-z"</span>;</div><div class="line"></div><div class="line"><span class="comment">// 初始化</span></div><div class="line"><span class="keyword">self</span>.fbKVO = [FBKVOController controllerWithObserver:<span class="keyword">self</span>];</div><div class="line"></div><div class="line"><span class="comment">// 注册监听并通过block方式直接获取</span></div><div class="line">[<span class="keyword">self</span>.fbKVO observe:model</div><div class="line">            keyPath:<span class="string">@"name"</span></div><div class="line">            options:<span class="built_in">NSKeyValueObservingOptionOld</span> | <span class="built_in">NSKeyValueObservingOptionNew</span></div><div class="line">              block:^(<span class="keyword">id</span> observer, <span class="keyword">id</span> object, <span class="built_in">NSDictionary</span> *change) &#123;</div><div class="line">    </div><div class="line">              <span class="built_in">NSLog</span>(<span class="string">@"change - %@"</span>,change[<span class="built_in">NSKeyValueChangeNewKey</span>]);</div><div class="line">&#125;];</div></pre></td></tr></table></figure></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 同时可以对model多个属性进行监听</span></div><div class="line">[<span class="keyword">self</span>.fbKVO observe:model</div><div class="line">         keyPaths:[<span class="built_in">NSArray</span> arrayWithObjects:<span class="string">@"name"</span>, <span class="string">@"age"</span>, <span class="literal">nil</span>]</div><div class="line">          options:<span class="built_in">NSKeyValueObservingOptionOld</span> | <span class="built_in">NSKeyValueObservingOptionNew</span></div><div class="line">            block:^(<span class="keyword">id</span> observer, <span class="keyword">id</span> object, <span class="built_in">NSDictionary</span> *change) &#123;</div><div class="line">    </div><div class="line">    		<span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,change);</div><div class="line">  &#125;];</div></pre></td></tr></table></figure>
<p>以上就是KVO的简单介绍和KVOController的使用。本文参考自<a href="http://draveness.me/kvocontroller/" target="_blank" rel="external">如何优雅地使用 KVO</a>，更多详细深入的内容请参考：☟</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="http://draveness.me/kvocontroller/" target="_blank" rel="external">如何优雅地使用 KVO</a></li>
<li><a href="http://zhangbuhuai.com/understanding-kvo/" target="_blank" rel="external">深入理解KVO</a></li>
<li><a href="http://www.cocoachina.com/industry/20140224/7866.html" target="_blank" rel="external">iOS KVC &amp; KVO</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Key-Value Observing，是iOS中的一种设计模式，用于检测对象的某些属性的实时变化情况并作出响应，这能够为我们在开发强交互、响应式应用以及实现视图和模型的双向绑定时提供大量的帮助。&lt;br&gt;KVO主要用于视图交互方面，比如界面的某些数据变化了，界面的显示也跟着需要变化，那就要建立数据和界面的关联。&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://note.snail-z.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="iOS" scheme="http://note.snail-z.me/tags/iOS/"/>
    
      <category term="Objective-C" scheme="http://note.snail-z.me/tags/Objective-C/"/>
    
      <category term="KVO" scheme="http://note.snail-z.me/tags/KVO/"/>
    
  </entry>
  
  <entry>
    <title>CADisplayLink学习笔记</title>
    <link href="http://note.snail-z.me/2017/03/17/CADisplayLink%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://note.snail-z.me/2017/03/17/CADisplayLink学习笔记/</id>
    <published>2017-03-17T14:21:32.000Z</published>
    <updated>2017-03-18T04:15:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>CADisplayLink相当于一个定时器，比起NSTimer，它可以确保系统渲染每一帧的时候我们的方法都被调用，从而保证了动画的流畅性。<br>iOS设备的屏幕刷新频率是固定的，CADisplayLink在正常情况下会在每次刷新结束都被调用，精确度相当高。NSTimer的精确度相对显得较低；CADisplayLink使用场合相对专一，适合做UI的不停重绘，比如自定义动画引擎或者视频播放的渲染。NSTimer的使用范围要广泛的多，各种需要单次或者循环定时处理的任务都可以使用。<br><a id="more"></a></p>
<h3 id="相关属性"><a href="#相关属性" class="headerlink" title="相关属性"></a>相关属性</h3><ol>
<li><code>preferredFramesPerSecond</code> （iOS10用这个方法）<br>标识每秒钟调用几次，比如每秒钟调用10次，那就是每0.1秒调用一次</li>
<li><code>frameInterval</code>（ios10被弃用）<br>标识间隔多少帧调用一次selector方法。<br>CADisplayLink的selector每秒调用次数 = 60 / frameInterval。<br>苹果文档中还提到：如果应用不能及时提供显示帧，则应该降低帧率，可以通过增大 frameInterval 这一属性的值来降低动画帧率。frameInterval 默认值为 1，表示每帧都回调一次selector。在没有卡顿时，iOS 设备屏幕显示每秒刷新60次，意味着 frameInterval 为默认值时，每秒回调60次 selector，当frameInterval 改为2时，每秒回调30（60/2）次 selector。</li>
<li><code>duration</code><br>只读的CFTimeInterval值，提供每帧之间的时间，也就是屏幕每次刷新的时间。</li>
<li><code>timestamp</code><br>只读的CFTimeInterval值，表示屏幕显示的上一帧的时间戳，这个属性通常被target用来计算下一帧中应该显示的内容。</li>
<li><code>paused</code><br>通过设置paused属性为YES可以暂停selector调用，默认值NO</li>
</ol>
<blockquote>
<p>注: CADisplayLink是不能被继承的</p>
</blockquote>
<h3 id="使用CADisplayLink"><a href="#使用CADisplayLink" class="headerlink" title="使用CADisplayLink"></a>使用CADisplayLink</h3><p>在应用中创建一个新的CADisplayLink 对象，把它添加到一个runloop中，并给他提供一个 target和select在屏幕刷新的时候调用。如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)startDisplayLink &#123;</div><div class="line">	<span class="keyword">if</span> (<span class="keyword">self</span>.displayLink == <span class="literal">nil</span>) &#123;  </div><div class="line">        <span class="keyword">self</span>.displayLink = [<span class="built_in">CADisplayLink</span> displayLinkWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(updateLayout)];  </div><div class="line">        [<span class="keyword">self</span>.displayLink addToRunLoop:[<span class="built_in">NSRunLoop</span> currentRunLoop] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];  </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)stopDisplayLink &#123;</div><div class="line">	<span class="comment">// 结束一个CADisplayLink，应该调用 - invalidate 从runloop中删除并删除之前绑定的 target跟selector</span></div><div class="line">	[<span class="keyword">self</span>.displayLink invalidate];</div><div class="line">	<span class="keyword">self</span>.displayLink = <span class="literal">nil</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">-(<span class="keyword">void</span>)updateLayout &#123;</div><div class="line">	<span class="comment">// do something</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>CADisplaylink 与 NSTimer 类似，都可以以一定的时间间隔触发回调 selector，不同点在于 CADisplaylink 的时间间隔是与屏幕的刷新频率相关联的，这一点决定了 CADisplaylink 的应用多与显示有关。</p>
</blockquote>
<h3 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h3><ul>
<li>当scrollview / tableview滚动时CADisplayLink停止响应。<br>要解决这个问题需要简单了解一下runloop的知识，runloop可以理解为cocoa下的一种消息循环机制，用来处理各种消息事件，我们在开发的时候并不需要手动去创建一个runloop，因为框架为我们创建了一个默认的runloop，通过[NSRunloop currentRunloop]可以得到一个当前线程下对应的runloop对象，不过需要注意的是不同的runloop之间消息的通知方式。在开启一个NSTimer或CADisplayLink实质上是在当前的runloop中注册了一个新的事件源，而当scrollView滚动的时候，当前的MainRunLoop是处于UITrackingRunLoopMode的模式下，在这个模式下是不会处理NSDefaultRunLoopMode的消息(因为RunLoop Mode不一样)，要想在scrollView滚动的同时也接受其它runloop的消息，就不能将Mode参数设置为NSDefaultRunLoopMode，而应该设置为NSRunLoopCommonModes。</li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="http://www.jianshu.com/p/c35a81c3b9eb" target="_blank" rel="external">CADisplayLink</a></li>
<li><a href="http://kittenyang.com/cadisplaylinkanduibezierpath/" target="_blank" rel="external">CADisplayLink结合UIBezierPath的神奇妙用</a></li>
<li><a href="http://tech.glowing.com/cn/usage-of-cadisplaylink/" target="_blank" rel="external">使用CADisplayLink实现果冻效果动画</a></li>
<li><a href="http://www.cnblogs.com/zhouxihi/p/6255669.html" target="_blank" rel="external">Objective-C三种定时器CADisplayLink / NSTimer / GCD的使用</a></li>
<li><a href="http://icetime17.github.io/2015/12/23/2015-12/iOS-%E4%BD%BF%E7%94%A8CADisplayLink%E6%9D%A5%E5%AE%9E%E7%8E%B0%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/" target="_blank" rel="external">iOS - 使用CADisplayLink来实现定时任务</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CADisplayLink相当于一个定时器，比起NSTimer，它可以确保系统渲染每一帧的时候我们的方法都被调用，从而保证了动画的流畅性。&lt;br&gt;iOS设备的屏幕刷新频率是固定的，CADisplayLink在正常情况下会在每次刷新结束都被调用，精确度相当高。NSTimer的精确度相对显得较低；CADisplayLink使用场合相对专一，适合做UI的不停重绘，比如自定义动画引擎或者视频播放的渲染。NSTimer的使用范围要广泛的多，各种需要单次或者循环定时处理的任务都可以使用。&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://note.snail-z.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="iOS" scheme="http://note.snail-z.me/tags/iOS/"/>
    
      <category term="Objective-C" scheme="http://note.snail-z.me/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>2017我在北京</title>
    <link href="http://note.snail-z.me/2017/03/16/2017%E6%88%91%E5%9C%A8%E5%8C%97%E4%BA%AC/"/>
    <id>http://note.snail-z.me/2017/03/16/2017我在北京/</id>
    <published>2017-03-15T16:18:53.000Z</published>
    <updated>2017-05-13T04:39:49.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="骑行"><a href="#骑行" class="headerlink" title="骑行"></a>骑行</h4><p>这是我们在北京的第一次骑行————永定河森林公园骑行。记得当年自己在上海骑车去看灰姑娘，电影结束后大雨滂沱，我没有王子，于是独自享受着在异乡的大雨中骑行，那时的我，那时的自行车，那时的伙伴，那时候的复旦，同济！我相信我还会继续在路上。<br><a id="more"></a></p>
<h4 id="藏身柳暗花明处"><a href="#藏身柳暗花明处" class="headerlink" title="藏身柳暗花明处"></a>藏身柳暗花明处</h4><p>来到北京后，我们在吵杂中用心感受这座城市，在它的怀抱中穿梭，有时候徒步，有时候骑行，有时候静静地坐在公交车上让眼睛悄悄地映着穿流的一切。玉渊潭的樱花，钓鱼台的银杏，香山的红叶，奥林匹克森林公园醉人的氧气！再怎么快节奏的生活，都会在这样的环境下慢下脚步，真心的想好好的过日子。</p>
<h4 id="逛京城"><a href="#逛京城" class="headerlink" title="逛京城"></a>逛京城</h4><p>西单，王府井，崇文门，国贸，三里屯，蓝色港湾，望京798，中关村，五道口，南锣鼓巷，雍和宫，簋街，立水桥，奥林匹克公园，故宫，长城等。我在这些地方留下了我的足迹。无论在哪里都离不开吃喝住行，在北京的吃喝住行还算是便利的，虽然南北有差异，但是在北京的生活并不让我排斥。</p>
<h4 id="谋生术"><a href="#谋生术" class="headerlink" title="谋生术"></a>谋生术</h4><p>工作就是做自己喜欢做的事情————敲代码。我喜欢做的事情很多，看书，画画，设计，总结一句就是看到美好的事物总是心生向往，想去触碰它。敲代码是一件我已经做了快4年的事情了。不是什么高手级别的，只是一年比一年对它更加熟悉，更加了解它，更想去了解它的点滴。对于想去了解它的动机也越来越单纯。它不再是一个用来挣钱养活自己的利器，而是它更加具有魅力，让我更想追寻着它奔跑。有人说追着累，而我有时候感觉看着它发展也挺高兴的。跟着它的脚步看它在未来某个时候蜕变或是变得消声觅迹也是一种心灵上的安慰。在这个互联网的时代，遍地是码农的时代，我只想做好自己，保持学习，分享的心态。</p>
<h4 id="流浪四海"><a href="#流浪四海" class="headerlink" title="流浪四海"></a>流浪四海</h4><p>曾经畅想过很多次我的老年生活————我希望到了某个年纪，有诗和远方。人总是喜欢用各种方式满足自己的好奇心。以前的生活很慢，慢得一生只够爱一个人。现在的生活很快，快到现在我在北京，晚上我估计已经在厦门和朋友聚餐了。这样的航空条件，还有当今的多媒体，让我们对整个国家乃至整个地球有了即视感。巴西的热带丛林，澳洲夏天的圣诞节，斯里兰卡的海岸线，欧洲的古老建筑，纽约的Open。我很想去亲身体验一下。想想这些场景，自己心里美滋滋的，脸上也洋溢的微笑，感觉棒棒的。这是我不敲代码想做的事情。(我会努力的带你走遍世界的每个角落~~)</p>
<p>— <a href="http://www.jianshu.com/p/17321419e238" target="_blank" rel="external">小鸿子的随笔</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;骑行&quot;&gt;&lt;a href=&quot;#骑行&quot; class=&quot;headerlink&quot; title=&quot;骑行&quot;&gt;&lt;/a&gt;骑行&lt;/h4&gt;&lt;p&gt;这是我们在北京的第一次骑行————永定河森林公园骑行。记得当年自己在上海骑车去看灰姑娘，电影结束后大雨滂沱，我没有王子，于是独自享受着在异乡的大雨中骑行，那时的我，那时的自行车，那时的伙伴，那时候的复旦，同济！我相信我还会继续在路上。&lt;br&gt;
    
    </summary>
    
      <category term="生活" scheme="http://note.snail-z.me/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="生活" scheme="http://note.snail-z.me/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>Hexo静态博客使用笔记</title>
    <link href="http://note.snail-z.me/2017/03/15/Hexo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%AC%94%E8%AE%B0/"/>
    <id>http://note.snail-z.me/2017/03/15/Hexo静态博客搭建笔记/</id>
    <published>2017-03-15T14:59:29.000Z</published>
    <updated>2017-03-18T14:44:12.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://hexo.io" target="_blank" rel="external">Hexo</a> 是一个基于 <a href="https://nodejs.org/en/" target="_blank" rel="external">Node.js</a> 的静态博客程序，可以方便的生成静态网页托管在 <a href="https://github.com/" target="_blank" rel="external">GitHub</a> 和 <a href="https://www.heroku.com/" target="_blank" rel="external">Heroku</a> 上。作者是来自台湾的 <a href="https://github.com/hexojs/hexo" target="_blank" rel="external">tommy351</a>。<br>关于hexo静态网页搭建过程本文不再赘述，网上教程很多，本篇末尾也有相应的网络链接供参考。本文只是简单记录下使用hexo中的一些问题和需求更改。<br><a id="more"></a></p>
<h3 id="关联Github仓库"><a href="#关联Github仓库" class="headerlink" title="关联Github仓库:"></a>关联Github仓库:</h3><p>在hexo根目录下的 _config.yml 文件配置，末尾添加如下信息<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">deploy:</span></div><div class="line">  <span class="symbol">type:</span> git</div><div class="line">  <span class="symbol">repository:</span> <span class="comment"># 你的 GitHub 仓库地址，别忘了加上 .git （我的是https://github.com/snail-z/snail-z.github.io.git）</span></div><div class="line">  <span class="symbol">branch:</span> master</div></pre></td></tr></table></figure></p>
<p>注意，配置文件的冒号后必须有一个空格。deploy 下面的每个字段前必须空两个空格，严格要求。</p>
<p>然后执行命令：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">hexo generate <span class="comment"># 生成静态页面，可以简化为 hexo g</span></div><div class="line">hexo deploy   <span class="comment"># 部署到 GitHub，可以简化为 hexo d</span></div></pre></td></tr></table></figure></p>
<p>浏览器访问 <a href="https://snail-z.github.io" target="_blank" rel="external">snail-z.github.io</a> 就能看到自己的 Blog 了，如果看到 404 页面不要惊慌，一般延迟半分钟左右才能看到效果。耐心等待。</p>
<hr>
<h3 id="添加网页背景图"><a href="#添加网页背景图" class="headerlink" title="添加网页背景图"></a>添加网页背景图</h3><p>具体做法是在<code>hexo/themes/next/source/css/_custom/</code>里的custom.styl修改如下：<br> <figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">#header &#123;</div><div class="line">    background: url("../images/background-header.jpg");</div><div class="line">    background-size: cover;</div><div class="line">&#125;</div><div class="line">body &#123;</div><div class="line">    background: url("../images/background-body.jpg");</div><div class="line">    background-size: cover;</div><div class="line">&#125;</div><div class="line">#footer &#123;</div><div class="line">    background: url("../images/background-footer.jpg");</div><div class="line">    background-size: cover;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p> 将上述中的图片放到<code>hexo/themes/next/source/images</code>中即可。</p>
<hr>
<h3 id="创建标签云页面和分类页面"><a href="#创建标签云页面和分类页面" class="headerlink" title="创建标签云页面和分类页面"></a>创建标签云页面和分类页面</h3><ul>
<li>添加标签云页面，并在menu中显示。</li>
</ul>
<ol>
<li><p>新建一个页面，命名为 tags 。命令如下</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo new page <span class="string">"tags"</span></div></pre></td></tr></table></figure>
</li>
<li><p>编辑刚新建的页面，在<code>hexo/source/tags</code>下的index.md文件中，将页面的类型设置为 tags ，主题将自动为这个页面显示标签云。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#title: All tags # 一般省略标题</span></div><div class="line"><span class="symbol">date:</span> <span class="number">2017</span>-<span class="number">3</span>-<span class="number">17</span> <span class="number">9</span><span class="symbol">:</span><span class="number">21</span><span class="symbol">:</span><span class="number">20</span></div><div class="line"><span class="symbol">type:</span> <span class="string">"tags"</span></div><div class="line"><span class="symbol">comments:</span> <span class="literal">false</span> <span class="comment"># 如果有启用多说评论，默认页面也会带有评论。需要关闭的话，添加字段comments设为false</span></div></pre></td></tr></table></figure>
</li>
<li><p>设置menu。编辑主题的_config.yml，添加tags到menu中，如下:</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">menu:</span></div><div class="line">  <span class="symbol">home:</span> /</div><div class="line">  <span class="symbol">archives:</span> /archives</div><div class="line">  <span class="symbol">tags:</span> /tags</div></pre></td></tr></table></figure>
</li>
<li><p>写文章时添加对应标签，例如本篇：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">title:</span> Hexo静态博客使用笔记</div><div class="line"><span class="symbol">date:</span> <span class="number">2017</span>-<span class="number">03</span>-<span class="number">15</span> <span class="number">22</span><span class="symbol">:</span><span class="number">59</span><span class="symbol">:</span><span class="number">29</span></div><div class="line"><span class="symbol">categories:</span>               <span class="comment"># 文章分类目录，可省略</span></div><div class="line">    - 技术</div><div class="line"><span class="symbol">tags:</span> Hexo</div><div class="line">---</div></pre></td></tr></table></figure>
<p>以上云标签就创建成功了，可以运行查看效果了。</p>
</li>
</ol>
<ul>
<li>添加分类页面</li>
</ul>
<ol>
<li><p>步骤与添加tags类似，首先新建一个页面，命名为 categories，如下：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo new page <span class="string">"categories"</span></div></pre></td></tr></table></figure>
</li>
<li><p>同样编辑刚新建的页面，将页面的类型设置为 categories ，主题将自动为这个页面显示所有分类。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">date:</span> <span class="number">2017</span>-<span class="number">03</span>-<span class="number">17</span> 09<span class="symbol">:</span><span class="number">25</span><span class="symbol">:</span><span class="number">20</span></div><div class="line"><span class="symbol">type:</span> <span class="string">"categories"</span></div><div class="line"><span class="symbol">comments:</span> <span class="literal">false</span></div></pre></td></tr></table></figure>
</li>
<li><p>在菜单中添加链接。编辑主题的 _config.yml ，将 menu 中的 categories: /categories 注释去掉，如下:</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">menu:</span></div><div class="line">  <span class="symbol">home:</span> /</div><div class="line">  <span class="symbol">categories:</span> /categories</div><div class="line">  <span class="symbol">archives:</span> /archives</div><div class="line">  <span class="symbol">tags:</span> /tags</div></pre></td></tr></table></figure>
<p>以上分类页面就创建成功了，打开博客查看效果吧。</p>
</li>
</ol>
<hr>
<h3 id="其它设置"><a href="#其它设置" class="headerlink" title="其它设置"></a>其它设置</h3><ul>
<li>单独修改文章字体颜色，在<code>hexo/themes/next/source/css/_variables/</code>下的<code>base.styl</code>文件中，定位到<code>$text-color = red</code>处，这样就将字体修改成了红色。默认#555</li>
<li>修改subtitle颜色，在<code>hexo/themes/next/source/css/_variables/</code>下的<code>base.styl</code>中定位到<code>$subtitle-color = red</code>，这改成了红色。默认#555</li>
<li>在主题配置 - NexT使用文档中提及了如何设置字体样式，这里就不再赘述了。如果想自定义字体大小以及颜色，可以直接在Markdown 文档编辑中使用<code>html</code>语法<br><code>&lt;font size=4 &gt; 这里输入文字，自定义大小 &lt;/font&gt;</code><br><code>&lt;font color=&quot;#FF0000&quot;&gt; 这里输入文字，自定义颜色的字体 &lt;/font&gt;</code></li>
</ul>
<hr>
<h3 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h3><ul>
<li><a href="https://note.leodev.me/2016/09/01/Hexo-3-1-1-Staic-Blog-Build-Guide/" target="_blank" rel="external">Hexo 3.1.1 静态博客搭建指南</a></li>
<li><a href="http://baixin.io/2015/08/HEXO搭建个人博客/" target="_blank" rel="external">HEXO搭建个人博客</a></li>
<li><a href="http://ibruce.info/2013/11/22/hexo-your-blog/" target="_blank" rel="external">hexo你的博客</a></li>
<li><a href="http://oakland.github.io/2016/04/30/hexo-%E5%A6%82%E4%BD%95%E6%9B%B4%E6%8D%A2%E4%B8%BB%E9%A2%98%E3%80%81%E5%88%A0%E9%99%A4%E6%96%87%E7%AB%A0/" target="_blank" rel="external">hexo如何更换主题、删除文章</a></li>
<li><a href="https://www.zybuluo.com/mdeditor" target="_blank" rel="external">Markdown 使用</a></li>
<li><a href="http://www.yaosansi.com/post/markdown-on-github/" target="_blank" rel="external">GitHub上Markdown基本使用</a></li>
<li><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="external">Hexo 使用文档</a></li>
<li><a href="http://theme-next.iissnan.com" target="_blank" rel="external">NexT 使用文档</a></li>
<li><a href="http://zhouhuix.cn/2016/11/24/%E4%BF%AE%E6%94%B9Hexo%E7%9A%84Next%E4%B8%BB%E9%A2%98/" target="_blank" rel="external">修改Hexo的Next主题</a></li>
<li><a href="https://www.fengyu.info/blog/2016/06/30/hexo-theme-next-modify/" target="_blank" rel="external">Hexo Next主题修改与优化 – 基础篇</a></li>
<li><a href="http://www.wuxubj.cn/2016/08/Hexo-nexT-build-personal-blog/" target="_blank" rel="external">Hexo+nexT主题搭建个人博客</a></li>
<li><a href="https://github.com/iissnan/hexo-theme-next/wiki" target="_blank" rel="external">hexo-theme-next wiki</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://hexo.io&quot;&gt;Hexo&lt;/a&gt; 是一个基于 &lt;a href=&quot;https://nodejs.org/en/&quot;&gt;Node.js&lt;/a&gt; 的静态博客程序，可以方便的生成静态网页托管在 &lt;a href=&quot;https://github.com/&quot;&gt;GitHub&lt;/a&gt; 和 &lt;a href=&quot;https://www.heroku.com/&quot;&gt;Heroku&lt;/a&gt; 上。作者是来自台湾的 &lt;a href=&quot;https://github.com/hexojs/hexo&quot;&gt;tommy351&lt;/a&gt;。&lt;br&gt;关于hexo静态网页搭建过程本文不再赘述，网上教程很多，本篇末尾也有相应的网络链接供参考。本文只是简单记录下使用hexo中的一些问题和需求更改。&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://note.snail-z.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Hexo" scheme="http://note.snail-z.me/tags/Hexo/"/>
    
  </entry>
  
</feed>
