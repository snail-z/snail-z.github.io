<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Snail-z Notes</title>
  <subtitle>书山有路勤为径，学海无涯苦作舟</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://note.snail-z.me/"/>
  <updated>2017-04-09T14:12:27.000Z</updated>
  <id>http://note.snail-z.me/</id>
  
  <author>
    <name>Snail-z</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>OC笔记</title>
    <link href="http://note.snail-z.me/2017/04/07/OC%E7%AC%94%E8%AE%B0/"/>
    <id>http://note.snail-z.me/2017/04/07/OC笔记/</id>
    <published>2017-04-07T13:56:56.000Z</published>
    <updated>2017-04-09T14:12:27.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="UIScrollview上的UIPangesturerecognizer冲突"><a href="#UIScrollview上的UIPangesturerecognizer冲突" class="headerlink" title="UIScrollview上的UIPangesturerecognizer冲突"></a>UIScrollview上的UIPangesturerecognizer冲突</h2><p>在tableview里的cell的imageview上加个UIPangesturerecognizer会发现优先滚动imageview，tableView不响应滚动了，原因是tableview的实现也是用了UIPangesturerecognizer。解决方案如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 实现 UIGestureRecognizerDelegate</span></div><div class="line">- (<span class="built_in">BOOL</span>)gestureRecognizer:(<span class="built_in">UIGestureRecognizer</span> *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(<span class="built_in">UIGestureRecognizer</span> *)otherGestureRecognizer &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<h2 id="CGRect函数"><a href="#CGRect函数" class="headerlink" title="CGRect函数"></a>CGRect函数</h2><ul>
<li><p>CGRectOffset使用从源CGRect偏移的原点来创建矩形</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">float</span> offset = <span class="number">25.0</span>;</div><div class="line">    <span class="built_in">CGRect</span> r1 = <span class="built_in">CGRectMake</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>);</div><div class="line">    <span class="built_in">CGRect</span> r2 = <span class="built_in">CGRectOffset</span>(r1, offset, offset);</div></pre></td></tr></table></figure>
</li>
<li><p>CGRectIntersectsRect允许我们确定两个矩形是否相交</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">float</span> offset = <span class="number">25.0</span>;</div><div class="line">    <span class="built_in">CGRect</span> r1 = <span class="built_in">CGRectMake</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>);</div><div class="line">    <span class="built_in">CGRect</span> r2 = <span class="built_in">CGRectMake</span>(<span class="number">150</span>, <span class="number">150</span>, <span class="number">100</span>, <span class="number">100</span>);</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">CGRectIntersectsRect</span>(r1, r2))</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"intersecting"</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>NSStringFromCGRect可以用来把CGRect显示到控制台</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">    <span class="built_in">CGRect</span> r1 = <span class="built_in">CGRectMake</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"rect:@%"</span>,<span class="built_in">NSStringFromCGRect</span>(r1));  </div><div class="line"><span class="comment">// 同样，CGRectFromString允许我们根据一个字符串创建一个CGRect：</span></div><div class="line">    <span class="built_in">NSString</span> *r = <span class="string">@"&#123;0,0&#125;,&#123;100,100&#125;"</span>;</div><div class="line">    <span class="built_in">CGRect</span> r1 = <span class="built_in">CGRectFromString</span>(r);</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="为视图某个角添加圆角"><a href="#为视图某个角添加圆角" class="headerlink" title="为视图某个角添加圆角"></a>为视图某个角添加圆角</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPathWithRoundedRect:aView.layer.bounds</div><div class="line">                                       byRoundingCorners:<span class="built_in">UIRectCornerTopLeft</span> | <span class="built_in">UIRectCornerBottomRight</span></div><div class="line">                                             cornerRadii:<span class="built_in">CGSizeMake</span>(<span class="number">25</span>, <span class="number">0</span>)];</div><div class="line"><span class="built_in">CAShapeLayer</span> *roundRectLayer = [[<span class="built_in">CAShapeLayer</span> alloc] init];</div><div class="line">roundRectLayer.frame  = aView.layer.bounds;</div><div class="line">roundRectLayer.path = path.CGPath;</div><div class="line">aView.layer.mask = roundRectLayer;</div><div class="line">aView.clipsToBounds = <span class="literal">NO</span>;</div></pre></td></tr></table></figure>
<p>若配置某个角为圆角的话,只需要指定对应的UIRectCorner即可：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UIRectCornerAllCorners</span> 	全角</div><div class="line"><span class="built_in">UIRectCornerTopLeft</span>    	左上角</div><div class="line"><span class="built_in">UIRectCornerTopRight</span>   	右上角</div><div class="line"><span class="built_in">UIRectCornerBottomLeft</span> 	左下角</div><div class="line"><span class="built_in">UIRectCornerBottomRight</span> 右下角</div></pre></td></tr></table></figure></p>
<h2 id="设置UITableView的分割线顶头"><a href="#设置UITableView的分割线顶头" class="headerlink" title="设置UITableView的分割线顶头"></a>设置UITableView的分割线顶头</h2><p>使用setSeparatorInset:UIEdgeInsetsZero来解决：</p>
<ol>
<li><p>直接对tableView进行设置：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ([_tableView respondsToSelector:<span class="keyword">@selector</span>(setSeparatorInset:)]) &#123;</div><div class="line">    [_tableView setSeparatorInset:<span class="built_in">UIEdgeInsetsZero</span>];</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> ([_tableView respondsToSelector:<span class="keyword">@selector</span>(setLayoutMargins:)]) &#123;</div><div class="line">    [_tableView setLayoutMargins:<span class="built_in">UIEdgeInsetsZero</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>实现UITableViewDelegate的代理方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)tableView:(<span class="built_in">UITableView</span> *)tableView willDisplayCell:(<span class="built_in">UITableViewCell</span> *)cell forRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</div><div class="line">    <span class="keyword">if</span> ([cell respondsToSelector:<span class="keyword">@selector</span>(setSeparatorInset:)]) &#123;</div><div class="line">        [cell setSeparatorInset:<span class="built_in">UIEdgeInsetsZero</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> ([cell respondsToSelector:<span class="keyword">@selector</span>(setLayoutMargins:)]) &#123;</div><div class="line">        [cell setLayoutMargins:<span class="built_in">UIEdgeInsetsZero</span>];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>去掉分割线 <code>_tableView.separatorStyle = UITableViewCellSeparatorStyleNone;</code></p>
<h2 id="Frame布局时使用CGRectInset设置左右、上下边距"><a href="#Frame布局时使用CGRectInset设置左右、上下边距" class="headerlink" title="Frame布局时使用CGRectInset设置左右、上下边距"></a>Frame布局时使用CGRectInset设置左右、上下边距</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UIView</span> *aView = [[<span class="built_in">UIView</span> alloc] initWithFrame:<span class="built_in">CGRectInset</span>(<span class="keyword">self</span>.view.bounds, <span class="number">10</span>, <span class="number">100</span>)];</div><div class="line">aView.backgroundColor = [<span class="built_in">UIColor</span> orangeColor];</div><div class="line">[<span class="keyword">self</span>.view addSubview:aView];</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;UIScrollview上的UIPangesturerecognizer冲突&quot;&gt;&lt;a href=&quot;#UIScrollview上的UIPangesturerecognizer冲突&quot; class=&quot;headerlink&quot; title=&quot;UIScrollview上的UIPangesturerecognizer冲突&quot;&gt;&lt;/a&gt;UIScrollview上的UIPangesturerecognizer冲突&lt;/h2&gt;&lt;p&gt;在tableview里的cell的imageview上加个UIPangesturerecognizer会发现优先滚动imageview，tableView不响应滚动了，原因是tableview的实现也是用了UIPangesturerecognizer。解决方案如下：&lt;br&gt;&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 实现 UIGestureRecognizerDelegate&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;- (&lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt;)gestureRecognizer:(&lt;span class=&quot;built_in&quot;&gt;UIGestureRecognizer&lt;/span&gt; *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(&lt;span class=&quot;built_in&quot;&gt;UIGestureRecognizer&lt;/span&gt; *)otherGestureRecognizer &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;YES&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://note.snail-z.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="iOS" scheme="http://note.snail-z.me/tags/iOS/"/>
    
      <category term="Objective-C" scheme="http://note.snail-z.me/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>iOS AutoLayout之 - NSLayoutConstraint</title>
    <link href="http://note.snail-z.me/2017/03/19/iOS%20AutoLayout%E4%B9%8B%20-%20NSLayoutConstraint/"/>
    <id>http://note.snail-z.me/2017/03/19/iOS AutoLayout之 - NSLayoutConstraint/</id>
    <published>2017-03-19T08:15:03.000Z</published>
    <updated>2017-03-25T04:31:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>AutoLayout是在iOS6之后推出的一种基于约束的，描述性的布局系统。使用约束条件来定义view的位置和尺寸。解决了不同分辨率和屏幕尺寸下view的适配问题，也简化了旋转时view位置的定义。<br>之前一直使用frame或第三方库<a href="https://github.com/SnapKit/Masonry.git" target="_blank" rel="external">Masonry</a>布局，对约束如何实现的并不清楚，所以抽时间进行了简单学习，并记录下如何使用纯代码NSLayoutConstraint实现autoLayout。<br><a id="more"></a></p>
<h3 id="显式创建约束方法constraintWithItem"><a href="#显式创建约束方法constraintWithItem" class="headerlink" title="显式创建约束方法constraintWithItem"></a>显式创建约束方法constraintWithItem</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">+(<span class="keyword">instancetype</span>)constraintWithItem:(<span class="keyword">id</span>)view1</div><div class="line">                        attribute:(<span class="built_in">NSLayoutAttribute</span>)attr1</div><div class="line">                        relatedBy:(<span class="built_in">NSLayoutRelation</span>)relation</div><div class="line">                           toItem:(<span class="keyword">nullable</span> <span class="keyword">id</span>)view2</div><div class="line">                        attribute:(<span class="built_in">NSLayoutAttribute</span>)attr2</div><div class="line">                       multiplier:(<span class="built_in">CGFloat</span>)multiplier</div><div class="line">                         constant:(<span class="built_in">CGFloat</span>)constant;</div></pre></td></tr></table></figure>
<ul>
<li><code>view1</code>：要添加约束的视图</li>
<li><code>attr1</code>：约束枚举<code>NSLayoutAttribute</code></li>
<li><code>relation</code>：与约束值的关系，大于 等于或小于</li>
<li><code>view2</code>：被参照对象</li>
<li><code>attr2</code>：被参照对象所被参照的枚举值<code>NSLayoutAttribute</code></li>
<li><code>multiplier</code>：乘数，确定间距倍数等关系（默认1.0） </li>
<li><code>constant</code>：差值常量<blockquote>
<p>注：view1与view2的位置和大小约束关系满足表达式:<br><code>view1.attr1 = view2.attr2 * multiplier + constant</code></p>
</blockquote>
</li>
</ul>
<p>简单介绍下NSLayoutAttribute的枚举值：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSLayoutAttributeLeft</span>：          <span class="comment">// 视图的x坐标，相当于CGRectGetMinX(view.frame)</span></div><div class="line"><span class="built_in">NSLayoutAttributeRight</span>：         <span class="comment">// CGRectGetMaxX(view.frame);</span></div><div class="line"><span class="built_in">NSLayoutAttributeTop</span>：           <span class="comment">// CGRectGetMinY(view.frame);</span></div><div class="line"><span class="built_in">NSLayoutAttributeBottom</span>：        <span class="comment">// CGRectGetMinY(view.frame);</span></div><div class="line"><span class="built_in">NSLayoutAttributeWidth</span>：         <span class="comment">// 视图宽度</span></div><div class="line"><span class="built_in">NSLayoutAttributeHeight</span>：        <span class="comment">// 视图高度</span></div><div class="line"><span class="built_in">NSLayoutAttributeCenterX</span>：       <span class="comment">// 视图中点的X值</span></div><div class="line"><span class="built_in">NSLayoutAttributeCenterY</span>：       <span class="comment">// 视图中点的Y值;</span></div><div class="line"><span class="built_in">NSLayoutAttributeBaseline</span>：      <span class="comment">// 视图的基准线</span></div><div class="line"><span class="built_in">NSLayoutAttributeLastBaseline</span>：  <span class="comment">// 相当于NSLayoutAttributeBaseline;</span></div><div class="line"><span class="built_in">NSLayoutAttributeFirstBaseline</span>： <span class="comment">// 文本上标线;</span></div><div class="line"><span class="built_in">NSLayoutAttributeNotAnAttribute</span>：<span class="comment">// None;</span></div><div class="line"></div><div class="line"><span class="built_in">NSLayoutAttributeLeading</span>： <span class="comment">// 在习惯由左向右看的地区，相当于NSLayoutAttributeLeft；在习惯从右至左看的地区，相当于NSLayoutAttributeRight;</span></div><div class="line"><span class="built_in">NSLayoutAttributeTrailing</span>：<span class="comment">// 在习惯由左向右看的地区，相当于NSLayoutAttributeRight；在习惯从右至左看的地区，相当于NSLayoutAttributeLeft;</span></div><div class="line"></div><div class="line"><span class="comment">// 以下iOS8新增属性，各种间距，网络查阅不少文章也没具体介绍，暂时我也不清楚，有时间会再详细测试。</span></div><div class="line"><span class="built_in">NSLayoutAttributeLeftMargin</span></div><div class="line"><span class="built_in">NSLayoutAttributeRightMargin</span></div><div class="line"><span class="built_in">NSLayoutAttributeTopMargin</span></div><div class="line"><span class="built_in">NSLayoutAttributeBottomMargin</span></div><div class="line"><span class="built_in">NSLayoutAttributeLeadingMargin</span></div><div class="line"><span class="built_in">NSLayoutAttributeTrailingMargin</span></div><div class="line"><span class="built_in">NSLayoutAttributeCenterXWithinMargins</span></div><div class="line"><span class="built_in">NSLayoutAttributeCenterYWithinMargins</span></div></pre></td></tr></table></figure></p>
<p>下面通过代码来了解constraintWithItem这个方法：</p>
<blockquote>
<p>注: 使用<code>Auto Layout</code>时，必须先将视图的<code>translatesAutoresizingMaskIntoConstraints</code>属性设为NO。因为当它为YES时，自己添加的约束会与系统的<code>Autoresizing Mask</code>约束产生冲突。</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建两个视图view1和view2</span></div><div class="line"><span class="built_in">UIView</span> *view1 = [[<span class="built_in">UIView</span> alloc] init];</div><div class="line">view1.backgroundColor = [<span class="built_in">UIColor</span> brownColor];</div><div class="line">[<span class="keyword">self</span>.view addSubview:view1];</div><div class="line"><span class="comment">// 不需要给view设置frame</span></div><div class="line"></div><div class="line"><span class="built_in">UIView</span> *view2 = [[<span class="built_in">UIView</span> alloc] init];</div><div class="line">view2.backgroundColor = [<span class="built_in">UIColor</span> orangeColor];</div><div class="line">[<span class="keyword">self</span>.view addSubview:view2];</div><div class="line"></div><div class="line"><span class="comment">// 关掉AutoresizingMask布局</span></div><div class="line">view1.translatesAutoresizingMaskIntoConstraints = <span class="literal">NO</span>;</div><div class="line">view2.translatesAutoresizingMaskIntoConstraints = <span class="literal">NO</span>;</div><div class="line"> </div><div class="line"><span class="comment">// view1：设置宽度为100px</span></div><div class="line">[<span class="keyword">self</span>.view addConstraint:[<span class="built_in">NSLayoutConstraint</span> constraintWithItem:view1</div><div class="line">                                                      attribute:<span class="built_in">NSLayoutAttributeWidth</span></div><div class="line">                                                      relatedBy:<span class="built_in">NSLayoutRelationEqual</span></div><div class="line">                                                         toItem:<span class="literal">nil</span></div><div class="line">                                                      attribute:<span class="built_in">NSLayoutAttributeNotAnAttribute</span></div><div class="line">                                                     multiplier:<span class="number">1</span></div><div class="line">                                                       constant:<span class="number">100</span>]];</div><div class="line"><span class="comment">// 如果是设置view自身的属性，不涉及到与其他view的位置约束关系时。constraintWithItem:方法的toItem参数应设为nil；且第五个参数attribute应设为NSLayoutAttributeNotAnAttribute </span></div><div class="line"><span class="comment">// 约束一定要添加在父视图上</span></div><div class="line"></div><div class="line"><span class="comment">// view1：设置高度等于宽度</span></div><div class="line">[<span class="keyword">self</span>.view addConstraint:[<span class="built_in">NSLayoutConstraint</span> constraintWithItem:view1</div><div class="line">                                                     attribute:<span class="built_in">NSLayoutAttributeHeight</span></div><div class="line">                                                     relatedBy:<span class="built_in">NSLayoutRelationEqual</span></div><div class="line">                                                        toItem:view1</div><div class="line">                                                     attribute:<span class="built_in">NSLayoutAttributeWidth</span></div><div class="line">                                                    multiplier:<span class="number">1</span></div><div class="line">                                                      constant:<span class="number">0</span>]];</div><div class="line"></div><div class="line"><span class="comment">// view1：设置在父视图水平方向上居中</span></div><div class="line">[<span class="keyword">self</span>.view addConstraint:[<span class="built_in">NSLayoutConstraint</span> constraintWithItem:view1</div><div class="line">                                                      attribute:<span class="built_in">NSLayoutAttributeCenterX</span></div><div class="line">                                                      relatedBy:<span class="built_in">NSLayoutRelationEqual</span></div><div class="line">                                                         toItem:<span class="keyword">self</span>.view</div><div class="line">                                                      attribute:<span class="built_in">NSLayoutAttributeCenterX</span></div><div class="line">                                                     multiplier:<span class="number">1</span></div><div class="line">                                                       constant:<span class="number">0</span>]];</div><div class="line"><span class="comment">// view1：设置在垂直方向上始终距离父视图底部为50px</span></div><div class="line">[<span class="keyword">self</span>.view addConstraint:[<span class="built_in">NSLayoutConstraint</span> constraintWithItem:view1</div><div class="line">                                                      attribute:<span class="built_in">NSLayoutAttributeBottom</span></div><div class="line">                                                      relatedBy:<span class="built_in">NSLayoutRelationEqual</span></div><div class="line">                                                         toItem:<span class="keyword">self</span>.view</div><div class="line">                                                      attribute:<span class="built_in">NSLayoutAttributeBottom</span></div><div class="line">                                                     multiplier:<span class="number">1</span></div><div class="line">                                                       constant:<span class="number">-50</span>]]; <span class="comment">// 类似的Bottom、Right设置为负</span></div><div class="line"></div><div class="line"><span class="comment">// view2：设置宽度是view1宽度的0.5倍</span></div><div class="line">[<span class="keyword">self</span>.view addConstraint:[<span class="built_in">NSLayoutConstraint</span> constraintWithItem:view2</div><div class="line">                                                      attribute:<span class="built_in">NSLayoutAttributeWidth</span></div><div class="line">                                                      relatedBy:<span class="built_in">NSLayoutRelationEqual</span></div><div class="line">                                                         toItem:view1</div><div class="line">                                                      attribute:<span class="built_in">NSLayoutAttributeWidth</span></div><div class="line">                                                     multiplier:<span class="number">0.5</span></div><div class="line">                                                       constant:<span class="number">0</span>]];</div><div class="line"></div><div class="line"><span class="comment">// view2：设置垂直方向上距父视图顶部100px</span></div><div class="line">[<span class="keyword">self</span>.view addConstraint:[<span class="built_in">NSLayoutConstraint</span> constraintWithItem:view2</div><div class="line">                                                      attribute:<span class="built_in">NSLayoutAttributeTop</span></div><div class="line">                                                      relatedBy:<span class="built_in">NSLayoutRelationEqual</span></div><div class="line">                                                         toItem:<span class="keyword">self</span>.view</div><div class="line">                                                      attribute:<span class="built_in">NSLayoutAttributeTop</span></div><div class="line">                                                     multiplier:<span class="number">1</span></div><div class="line">                                                       constant:<span class="number">100</span>]];</div><div class="line"></div><div class="line"><span class="comment">// view2：设置垂直方向上距view1顶部50px</span></div><div class="line">[<span class="keyword">self</span>.view addConstraint:[<span class="built_in">NSLayoutConstraint</span> constraintWithItem:view2</div><div class="line">                                                      attribute:<span class="built_in">NSLayoutAttributeBottom</span></div><div class="line">                                                      relatedBy:<span class="built_in">NSLayoutRelationEqual</span></div><div class="line">                                                         toItem:view1</div><div class="line">                                                      attribute:<span class="built_in">NSLayoutAttributeTop</span></div><div class="line">                                                     multiplier:<span class="number">1</span></div><div class="line">                                                       constant:<span class="number">-50</span>]];</div><div class="line"><span class="comment">// 通过以上两个条件可以确定高度，所以不需要再设置高度。</span></div><div class="line"></div><div class="line"><span class="comment">//view2：最后设置水平方向上距离父视图的左边间距与距离view1的间距相等</span></div><div class="line">[<span class="keyword">self</span>.view addConstraint:[<span class="built_in">NSLayoutConstraint</span> constraintWithItem:view2</div><div class="line">                                                      attribute:<span class="built_in">NSLayoutAttributeCenterX</span></div><div class="line">                                                      relatedBy:<span class="built_in">NSLayoutRelationEqual</span></div><div class="line">                                                         toItem:view1</div><div class="line">                                                      attribute:<span class="built_in">NSLayoutAttributeLeft</span></div><div class="line">                                                     multiplier:<span class="number">0.5</span></div><div class="line">                                                       constant:<span class="number">0</span>]];</div></pre></td></tr></table></figure>
<p>运行程序查看效果，也可以大致参考下图的简单说明：</p>
<p><img src="https://github.com/snail-z/snail-z.github.io/blob/master/images/constraint1.png?raw=true" alt="image"></p>
<hr>
<h3 id="使用VFL-即Visual-Format-Language-可视化格式语言创建约束"><a href="#使用VFL-即Visual-Format-Language-可视化格式语言创建约束" class="headerlink" title="使用VFL(即Visual Format Language)可视化格式语言创建约束"></a>使用VFL(即Visual Format Language)可视化格式语言创建约束</h3><p>VFL的API<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">NSArray</span>&lt;<span class="built_in">NSLayoutConstraint</span> *&gt; *)constraintsWithVisualFormat:(<span class="built_in">NSString</span> *)format</div><div class="line">                                                       options:(<span class="built_in">NSLayoutFormatOptions</span>)opts</div><div class="line">                                                       metrics:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *,<span class="keyword">id</span>&gt; *)metrics</div><div class="line">                                                         views:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)views;</div></pre></td></tr></table></figure></p>
<ul>
<li><code>format</code>：VFL格式字符串</li>
<li><code>opts</code>： 对齐方式的枚举值<code>NSLayoutFormatOptions</code></li>
<li><code>metrics</code>：设置需要进行替换的值，是字典类型，通过下面代码加以理解</li>
<li><code>views</code>：传入约束中用到的views，也是字典类型。注意字典中的values一定要和format参数里所写的views名字相同</li>
</ul>
<p>部分NSLayoutFormatOptions的枚举值介绍：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSLayoutFormatAlignAllLeft</span> = (<span class="number">1</span> &lt;&lt; <span class="built_in">NSLayoutAttributeLeft</span>)：      <span class="comment">// 左边对齐</span></div><div class="line"><span class="built_in">NSLayoutFormatAlignAllRight</span> = (<span class="number">1</span> &lt;&lt; <span class="built_in">NSLayoutAttributeRight</span>)：    <span class="comment">// 右边对齐</span></div><div class="line"><span class="built_in">NSLayoutFormatAlignAllTop</span> = (<span class="number">1</span> &lt;&lt; <span class="built_in">NSLayoutAttributeTop</span>)：        <span class="comment">// 顶部对齐</span></div><div class="line"><span class="built_in">NSLayoutFormatAlignAllBottom</span> = (<span class="number">1</span> &lt;&lt; <span class="built_in">NSLayoutAttributeBottom</span>)：  <span class="comment">// 底部对齐</span></div><div class="line"><span class="built_in">NSLayoutFormatAlignAllCenterX</span> = (<span class="number">1</span> &lt;&lt; <span class="built_in">NSLayoutAttributeCenterX</span>)：<span class="comment">// 垂直方向中心对齐</span></div><div class="line"><span class="built_in">NSLayoutFormatAlignAllCenterY</span> = (<span class="number">1</span> &lt;&lt; <span class="built_in">NSLayoutAttributeCenterY</span>)：<span class="comment">// 水平方向中心对齐</span></div></pre></td></tr></table></figure></p>
<p>下面通过代码来了解constraintsWithVisualFormat这个方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建视图</span></div><div class="line"><span class="built_in">UIView</span> *view1 = [[<span class="built_in">UIView</span> alloc] init];</div><div class="line">view1.backgroundColor = [<span class="built_in">UIColor</span> brownColor];</div><div class="line">[<span class="keyword">self</span>.view addSubview:view1];</div><div class="line"></div><div class="line"><span class="comment">// 关掉AutoresizingMask</span></div><div class="line">view1.translatesAutoresizingMaskIntoConstraints = <span class="literal">NO</span>;</div><div class="line"></div><div class="line"><span class="comment">// ①</span></div><div class="line"><span class="built_in">NSDictionary</span> *viewsDict = <span class="built_in">NSDictionaryOfVariableBindings</span>(view1);</div><div class="line"></div><div class="line"><span class="comment">// ②</span></div><div class="line"><span class="built_in">NSArray</span> *constraints1 = [<span class="built_in">NSLayoutConstraint</span> constraintsWithVisualFormat:<span class="string">@"H:|-[view1]-50-|"</span></div><div class="line">                                                                options:<span class="number">0</span></div><div class="line">                                                                metrics:<span class="literal">nil</span></div><div class="line">                                                                  views:viewsDict];</div><div class="line"></div><div class="line"><span class="comment">// ③</span></div><div class="line"><span class="built_in">NSArray</span> *constraints2 = [<span class="built_in">NSLayoutConstraint</span> constraintsWithVisualFormat:<span class="string">@"V:|-100-[view1(==200)]"</span></div><div class="line">                                                                options:<span class="number">0</span></div><div class="line">                                                                metrics:<span class="literal">nil</span></div><div class="line">                                                                  views:viewsDict];</div><div class="line"></div><div class="line"><span class="comment">// 使用addConstraints添加约束</span></div><div class="line">[<span class="keyword">self</span>.view addConstraints:constraints1];</div><div class="line">[<span class="keyword">self</span>.view addConstraints:constraints2];</div></pre></td></tr></table></figure>
<p>下面介绍上面代码中的标记：<br>① <code>NSDictionaryOfVariableBindings(view1)</code>：<br>    这是个宏定义，字典格式可以理解为 <code>@{ @&quot;view1&quot; : @&quot;view1&quot;};</code> 相当于将key - value进行对应绑定；因为在VFL中是通过key来寻找对应的value。比如<code>@{@&quot;aView&quot; : @&quot;self.sView&quot;}</code>它会布局self.sView而不是aView。所以你在VFL中看到的变量是key，而不是value。</p>
<blockquote>
<p>注：在format字符串里或是在binding字典里，都应该避免使用类似self.view1这样的字样，可以使用<code>_view1</code>。</p>
</blockquote>
<p>② <code>@&quot;H:|-[view1]-50-|&quot;</code> ：<br>    <code>H:</code> 表示在水平方向上添加约束（H即horizontal）；<br>    <code>|</code> 是表示父视图；<br>    <code>-</code> 表示一个间距；如果未设置间距值，当和父视图之间时，默认代表20px（可看作-20-），如果是两个同级别的view，比如<code>@&quot;[view1]-[view2]&quot;</code>，则表示8px；<br>    所以这句话可理解为view1在水平方向上距父视图左边20px，距离父视图右边50px</p>
<p>③ <code>@&quot;V:|-100-[view1(==200)]&quot;</code> ：<br>    <code>V:</code> 表示在垂直方向上添加约束（V即vertical）；<br>    <code>[view1(==200)]</code> 如果是在垂直方向上则表示view1的高度等200，水平方向则表示宽等某个值，可省略<code>==</code> 简化为<code>[view1(200)]</code>；<br>    由于确定了高度，所以底部间距不用设置，不然会起冲突。所以这句话可理解为view1在垂直方向上距父视图顶部100px，高为200px</p>
<p>再通过一个例子加深理解：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UIView</span> *sView = [[<span class="built_in">UIView</span> alloc] init];</div><div class="line">sView.backgroundColor = [<span class="built_in">UIColor</span> darkGrayColor];</div><div class="line">[<span class="keyword">self</span>.view addSubview:sView];</div><div class="line"></div><div class="line"><span class="built_in">UIView</span> *view1 = [[<span class="built_in">UIView</span> alloc] init];</div><div class="line">view1.backgroundColor = [<span class="built_in">UIColor</span> brownColor];</div><div class="line">[sView addSubview:view1];</div><div class="line"></div><div class="line"><span class="built_in">UIView</span> *view2 = [[<span class="built_in">UIView</span> alloc] init];</div><div class="line">view2.backgroundColor = [<span class="built_in">UIColor</span> orangeColor];</div><div class="line">[sView addSubview:view2]; <span class="comment">// 将view1 view2添加到sView上</span></div><div class="line"></div><div class="line"><span class="comment">// 关掉AutoresizingMask布局</span></div><div class="line">sView.translatesAutoresizingMaskIntoConstraints = <span class="literal">NO</span>;</div><div class="line">view1.translatesAutoresizingMaskIntoConstraints = <span class="literal">NO</span>;</div><div class="line">view2.translatesAutoresizingMaskIntoConstraints = <span class="literal">NO</span>;</div><div class="line"></div><div class="line"><span class="built_in">NSDictionary</span> *viewsDict = <span class="built_in">NSDictionaryOfVariableBindings</span>(sView, view1, view2);</div><div class="line"></div><div class="line"><span class="comment">// 设置间距和宽度要进行替换的值</span></div><div class="line"><span class="built_in">NSDictionary</span> *metricsDict = @&#123;<span class="string">@"padding"</span> : @<span class="number">50</span>, <span class="string">@"height"</span> : @<span class="number">150</span>&#125;;</div><div class="line"></div><div class="line"><span class="comment">// sView：水平方向布局</span></div><div class="line"><span class="built_in">NSArray</span> *constraints1 = [<span class="built_in">NSLayoutConstraint</span> constraintsWithVisualFormat:<span class="string">@"H:|-padding-[sView]-padding-|"</span></div><div class="line">                                                                options:kNilOptions</div><div class="line">                                                                metrics:metricsDict</div><div class="line">                                                                  views:viewsDict];</div><div class="line"></div><div class="line"><span class="comment">// sView：垂直方向布局</span></div><div class="line"><span class="built_in">NSArray</span> *constraints2 = [<span class="built_in">NSLayoutConstraint</span> constraintsWithVisualFormat:<span class="string">@"V:[sView(height)]-padding-|"</span></div><div class="line">                                                                options:kNilOptions</div><div class="line">                                                                metrics:metricsDict</div><div class="line">                                                                  views:viewsDict];</div><div class="line"></div><div class="line"><span class="comment">// 使用addConstraints添加约束</span></div><div class="line">[<span class="keyword">self</span>.view addConstraints:constraints1];</div><div class="line">[<span class="keyword">self</span>.view addConstraints:constraints2];</div><div class="line"></div><div class="line"><span class="comment">// view1 - view2：水平方向布局</span></div><div class="line"><span class="comment">// 设置对齐方式，view2顶部与底部都与view1对齐</span></div><div class="line"><span class="built_in">NSLayoutFormatOptions</span> options = <span class="built_in">NSLayoutFormatAlignAllTop</span> | <span class="built_in">NSLayoutFormatAlignAllBottom</span>;</div><div class="line"></div><div class="line"><span class="built_in">NSArray</span> *constraints3 = [<span class="built_in">NSLayoutConstraint</span> constraintsWithVisualFormat:<span class="string">@"H:|-15-[view1(100)]-padding-[view2]-15-|"</span></div><div class="line">                                                                options:options</div><div class="line">                                                                metrics:metricsDict</div><div class="line">                                                                  views:viewsDict];</div><div class="line"></div><div class="line"><span class="comment">// view1：垂直方向布局，根据设置的对齐方式可以确定view2高度与view1相等，所以不需要再进行对view2垂直方向上的布局</span></div><div class="line"><span class="built_in">NSArray</span> *constraints4 = [<span class="built_in">NSLayoutConstraint</span> constraintsWithVisualFormat:<span class="string">@"V:|-15-[view1]-15-|"</span></div><div class="line">                                                                options:kNilOptions</div><div class="line">                                                                metrics:metricsDict</div><div class="line">                                                                  views:viewsDict];</div><div class="line"></div><div class="line">[sView addConstraints:constraints3];</div><div class="line">[sView addConstraints:constraints4];</div><div class="line"></div><div class="line"><span class="comment">// 继续创建一个视图redView</span></div><div class="line"><span class="built_in">UIView</span> *redView = [[<span class="built_in">UIView</span> alloc] init];</div><div class="line">redView.backgroundColor = [<span class="built_in">UIColor</span> redColor];</div><div class="line">redView.translatesAutoresizingMaskIntoConstraints = <span class="literal">NO</span>;</div><div class="line">[<span class="keyword">self</span>.view addSubview:redView];</div><div class="line"></div><div class="line"><span class="comment">// 设置redView的左右两端对齐sView且高度等于sView的高</span></div><div class="line"><span class="built_in">NSArray</span> *constraints5 = [<span class="built_in">NSLayoutConstraint</span></div><div class="line">                        constraintsWithVisualFormat:<span class="string">@"V:[redView(sView)]-15-[sView]"</span></div><div class="line">                        options:<span class="built_in">NSLayoutFormatAlignAllLeft</span> | <span class="built_in">NSLayoutFormatAlignAllRight</span></div><div class="line">                        metrics:<span class="literal">nil</span></div><div class="line">                        views:<span class="built_in">NSDictionaryOfVariableBindings</span>(sView, redView)];</div><div class="line"></div><div class="line">[<span class="keyword">self</span>.view addConstraints:constraints5];</div></pre></td></tr></table></figure></p>
<p>查看运行效果，大致如下：</p>
<p><img src="https://github.com/snail-z/snail-z.github.io/blob/master/images/constraint2.png?raw=true" alt="image"></p>
<hr>
<h3 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h3><ul>
<li>假如设置三个视图的宽高固定为50px，如何让三个视图在垂直方向上居中且等分所有间距？</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 简单将宽高的约束进行封装</span></div><div class="line">- (<span class="built_in">NSArray</span>&lt;<span class="built_in">NSLayoutConstraint</span> *&gt; *)constraintSize:(<span class="built_in">CGSize</span>)size forView:(<span class="built_in">UIView</span> *)view &#123;</div><div class="line">    </div><div class="line">    <span class="built_in">NSLayoutConstraint</span> *constraintWidth = [<span class="built_in">NSLayoutConstraint</span></div><div class="line">                                           constraintWithItem:view</div><div class="line">                                           attribute:<span class="built_in">NSLayoutAttributeWidth</span></div><div class="line">                                           relatedBy:<span class="built_in">NSLayoutRelationEqual</span></div><div class="line">                                           toItem:<span class="literal">nil</span></div><div class="line">                                           attribute:<span class="built_in">NSLayoutAttributeNotAnAttribute</span></div><div class="line">                                           multiplier:<span class="number">1</span></div><div class="line">                                           constant:size.width];</div><div class="line">    </div><div class="line">    <span class="built_in">NSLayoutConstraint</span> *constraintHeight = [<span class="built_in">NSLayoutConstraint</span></div><div class="line">                                            constraintWithItem:view</div><div class="line">                                            attribute:<span class="built_in">NSLayoutAttributeHeight</span></div><div class="line">                                            relatedBy:<span class="built_in">NSLayoutRelationEqual</span></div><div class="line">                                            toItem:<span class="literal">nil</span></div><div class="line">                                            attribute:<span class="built_in">NSLayoutAttributeNotAnAttribute</span></div><div class="line">                                            multiplier:<span class="number">1</span></div><div class="line">                                            constant:size.height];</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> @[constraintWidth, constraintHeight];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 简单的将constraintWithItem方法简化封装</span></div><div class="line">- (<span class="built_in">NSLayoutConstraint</span> *)constraintView:(<span class="built_in">UIView</span> *)item</div><div class="line">                             attribute:(<span class="built_in">NSLayoutAttribute</span>)attr1</div><div class="line">                                toView:(<span class="built_in">UIView</span> *)toView</div><div class="line">                             attribute:(<span class="built_in">NSLayoutAttribute</span>)attr2 &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> [<span class="built_in">NSLayoutConstraint</span> constraintWithItem:item</div><div class="line">                                        attribute:attr1</div><div class="line">                                        relatedBy:<span class="built_in">NSLayoutRelationEqual</span></div><div class="line">                                           toItem:toView</div><div class="line">                                        attribute:attr2</div><div class="line">                                       multiplier:<span class="number">1</span></div><div class="line">                                         constant:<span class="number">0</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>思路：因为是三个视图，所以会等分四个间距，可以通过辅助视图来填充间距，且每个辅助视图的宽是相等的，然后和固定的三个视图的宽的总和等于父视图的宽。详细参考下面代码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 设置三个视图的宽高固定为50px，让三个视图在垂直方向上居中且等分所有间距。</span></div><div class="line">- (<span class="keyword">void</span>)example7 &#123;</div><div class="line">  <span class="built_in">NSInteger</span> N = <span class="number">3</span>;</div><div class="line">  <span class="built_in">CGSize</span> _size = <span class="built_in">CGSizeMake</span>(<span class="number">50</span>, <span class="number">50</span>);</div><div class="line"></div><div class="line">  <span class="comment">// 创建第一个辅助视图，也是用它来保存上一个辅助视图</span></div><div class="line">  <span class="built_in">UIView</span> *lastHelperView = [<span class="built_in">UIView</span> new];</div><div class="line">  lastHelperView.backgroundColor = [<span class="built_in">UIColor</span> darkGrayColor];</div><div class="line">  [<span class="keyword">self</span>.view addSubview:lastHelperView];</div><div class="line">  lastHelperView.translatesAutoresizingMaskIntoConstraints = <span class="literal">NO</span>;</div><div class="line"></div><div class="line">   <span class="comment">// 添加上边约束</span></div><div class="line">    [<span class="keyword">self</span>.view addConstraint:[<span class="keyword">self</span> constraintView:lastHelperView</div><div class="line">                                        attribute:<span class="built_in">NSLayoutAttributeTop</span></div><div class="line">                                           toView:<span class="keyword">self</span>.view</div><div class="line">                                        attribute:<span class="built_in">NSLayoutAttributeTop</span>]];</div><div class="line">    <span class="comment">// 下</span></div><div class="line">    [<span class="keyword">self</span>.view addConstraint:[<span class="keyword">self</span> constraintView:lastHelperView</div><div class="line">                                        attribute:<span class="built_in">NSLayoutAttributeBottom</span></div><div class="line">                                           toView:<span class="keyword">self</span>.view</div><div class="line">                                        attribute:<span class="built_in">NSLayoutAttributeBottom</span>]];</div><div class="line">    <span class="comment">// 左</span></div><div class="line">    [<span class="keyword">self</span>.view addConstraint:[<span class="keyword">self</span> constraintView:lastHelperView</div><div class="line">                                        attribute:<span class="built_in">NSLayoutAttributeLeft</span></div><div class="line">                                           toView:<span class="keyword">self</span>.view</div><div class="line">                                        attribute:<span class="built_in">NSLayoutAttributeLeft</span>]];</div><div class="line">  <span class="comment">// 循环创建</span></div><div class="line">  <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</div><div class="line">        </div><div class="line">        <span class="built_in">UIView</span> *view = [<span class="built_in">UIView</span> new];</div><div class="line">        view.backgroundColor = [<span class="built_in">UIColor</span> orangeColor];</div><div class="line">        view.translatesAutoresizingMaskIntoConstraints = <span class="literal">NO</span>;</div><div class="line">        [<span class="keyword">self</span>.view addSubview:view];</div><div class="line">        </div><div class="line">        <span class="comment">// 固定view宽高为50px</span></div><div class="line">        [<span class="keyword">self</span>.view addConstraints:[<span class="keyword">self</span> constraintSize:_size forView:view]];</div><div class="line">        <span class="comment">// CenterY居中</span></div><div class="line">        [<span class="keyword">self</span>.view addConstraint:[<span class="keyword">self</span> constraintView:view</div><div class="line">                                            attribute:<span class="built_in">NSLayoutAttributeCenterY</span></div><div class="line">                                               toView:<span class="keyword">self</span>.view</div><div class="line">                                            attribute:<span class="built_in">NSLayoutAttributeCenterY</span>]];</div><div class="line">        <span class="comment">// 左边约束</span></div><div class="line">        [<span class="keyword">self</span>.view addConstraint:[<span class="keyword">self</span> constraintView:view</div><div class="line">                                            attribute:<span class="built_in">NSLayoutAttributeLeft</span></div><div class="line">                                               toView:lastHelperView</div><div class="line">                                            attribute:<span class="built_in">NSLayoutAttributeRight</span>]];</div><div class="line">        </div><div class="line">        <span class="built_in">UIView</span> *helperView = [<span class="built_in">UIView</span> new];</div><div class="line">        helperView.backgroundColor = [<span class="built_in">UIColor</span> darkGrayColor];</div><div class="line">        [<span class="keyword">self</span>.view addSubview:helperView];</div><div class="line">        helperView.translatesAutoresizingMaskIntoConstraints = <span class="literal">NO</span>;</div><div class="line">        <span class="comment">// 上</span></div><div class="line">        [<span class="keyword">self</span>.view addConstraint:[<span class="keyword">self</span> constraintView:helperView</div><div class="line">                                            attribute:<span class="built_in">NSLayoutAttributeTop</span></div><div class="line">                                               toView:<span class="keyword">self</span>.view</div><div class="line">                                            attribute:<span class="built_in">NSLayoutAttributeTop</span>]];</div><div class="line">        <span class="comment">// 下</span></div><div class="line">        [<span class="keyword">self</span>.view addConstraint:[<span class="keyword">self</span> constraintView:helperView</div><div class="line">                                            attribute:<span class="built_in">NSLayoutAttributeBottom</span></div><div class="line">                                               toView:<span class="keyword">self</span>.view</div><div class="line">                                            attribute:<span class="built_in">NSLayoutAttributeBottom</span>]];</div><div class="line">        <span class="comment">// 等间距约束（即等宽）</span></div><div class="line">        [<span class="keyword">self</span>.view addConstraint:[<span class="keyword">self</span> constraintView:helperView</div><div class="line">                                            attribute:<span class="built_in">NSLayoutAttributeWidth</span></div><div class="line">                                               toView:lastHelperView</div><div class="line">                                            attribute:<span class="built_in">NSLayoutAttributeWidth</span>]];</div><div class="line">        <span class="comment">// 左</span></div><div class="line">        [<span class="keyword">self</span>.view addConstraint:[<span class="keyword">self</span> constraintView:helperView</div><div class="line">                                            attribute:<span class="built_in">NSLayoutAttributeLeft</span></div><div class="line">                                               toView:view</div><div class="line">                                            attribute:<span class="built_in">NSLayoutAttributeRight</span>]];</div><div class="line">        lastHelperView = helperView;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 为最后一个helperView添加右边约束</span></div><div class="line">    [<span class="keyword">self</span>.view addConstraint:[<span class="keyword">self</span> constraintView:lastHelperView</div><div class="line">                                        attribute:<span class="built_in">NSLayoutAttributeRight</span></div><div class="line">                                           toView:<span class="keyword">self</span>.view</div><div class="line">                                        attribute:<span class="built_in">NSLayoutAttributeRight</span>]];</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行查看效果：<br><img src="https://github.com/snail-z/snail-z.github.io/blob/master/images/constraint3.png?raw=true" alt="image"></p>
<p>以上就是对NSLayoutConstraint学习做的笔记和遇到的问题，后期会在进行深入理解研究~~<br>本文<a href="https://github.com/snail-z/blog-demos.git" target="_blank" rel="external">Demo</a>已经上传至github，在里面的AutoLayout-Notes目录下。</p>
<hr>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="http://adad184.com/2014/09/28/use-masonry-to-quick-solve-autolayout/" target="_blank" rel="external">Masonry介绍与使用实践(快速上手Autolayout)</a></li>
<li><a href="http://tutuge.me/2015/12/14/autolayout-example-with-masonry3/" target="_blank" rel="external">有趣的Autolayout示例三-Masonry实现</a></li>
<li><a href="http://jinqianchina.github.io/2016/04/29/iOS%E5%BC%80%E5%8F%91-%E8%87%AA%E5%8A%A8%E5%B8%83%E5%B1%80%E7%AF%87%EF%BC%9A%E5%8F%B2%E4%B8%8A%E6%9C%80%E7%89%9B%E7%9A%84%E8%87%AA%E5%8A%A8%E5%B8%83%E5%B1%80%E6%95%99%E5%AD%A6%EF%BC%81/" target="_blank" rel="external">iOS开发-自动布局篇</a></li>
<li><a href="http://www.jianshu.com/p/d7a4790090f1" target="_blank" rel="external">iOS Autolayout解读</a></li>
<li><a href="https://github.com/nixzhu/dev-blog/blob/master/autolayout-tips.md#tip-1" target="_blank" rel="external">AutoLayout Tips - 两个不等宽的View，彼此相邻并”共同”居中于Superview</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;AutoLayout是在iOS6之后推出的一种基于约束的，描述性的布局系统。使用约束条件来定义view的位置和尺寸。解决了不同分辨率和屏幕尺寸下view的适配问题，也简化了旋转时view位置的定义。&lt;br&gt;之前一直使用frame或第三方库&lt;a href=&quot;https://github.com/SnapKit/Masonry.git&quot;&gt;Masonry&lt;/a&gt;布局，对约束如何实现的并不清楚，所以抽时间进行了简单学习，并记录下如何使用纯代码NSLayoutConstraint实现autoLayout。&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://note.snail-z.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="iOS" scheme="http://note.snail-z.me/tags/iOS/"/>
    
      <category term="Objective-C" scheme="http://note.snail-z.me/tags/Objective-C/"/>
    
      <category term="AutoLayout" scheme="http://note.snail-z.me/tags/AutoLayout/"/>
    
  </entry>
  
  <entry>
    <title>Cocoa中的键值观察 - KVO</title>
    <link href="http://note.snail-z.me/2017/03/18/Cocoa%E4%B8%AD%E7%9A%84%E9%94%AE%E5%80%BC%E8%A7%82%E5%AF%9F%20-%20KVO/"/>
    <id>http://note.snail-z.me/2017/03/18/Cocoa中的键值观察 - KVO/</id>
    <published>2017-03-18T03:28:30.000Z</published>
    <updated>2017-03-18T08:54:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>Key-Value Observing，是iOS中的一种设计模式，用于检测对象的某些属性的实时变化情况并作出响应，这能够为我们在开发强交互、响应式应用以及实现视图和模型的双向绑定时提供大量的帮助。<br>KVO主要用于视图交互方面，比如界面的某些数据变化了，界面的显示也跟着需要变化，那就要建立数据和界面的关联。<br><a id="more"></a></p>
<h3 id="原生KVO"><a href="#原生KVO" class="headerlink" title="原生KVO"></a>原生KVO</h3><p><font color="#008B8B"> 订阅 </font>：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)addObserver:(<span class="built_in">NSObject</span> *)observer</div><div class="line">         forKeyPath:(<span class="built_in">NSString</span> *)keyPath</div><div class="line">            options:(<span class="built_in">NSKeyValueObservingOptions</span>)options</div><div class="line">            context:(<span class="keyword">void</span> *)context;</div></pre></td></tr></table></figure></p>
<ul>
<li><code>observer</code>：KVO通知的对象注册。观察者必须实现键值观察方法</li>
<li><code>keyPath</code>：关联路径，即被观察的属性。不能设置为nil</li>
<li><code>options</code>：options可选值是一个NSKeyValueObservingOptions枚举值；首先了解一个概念，即KVO响应方法有一个NSDictionary类型参数change，这个字典中会有一个与被监听属性相关的值，譬如被改变之前的值、新值等，NSDictionary中有什么值由订阅时的options值决定，options可取值如下：<ul>
<li>NSKeyValueObservingOptionNew: 指示change字典中包含新属性值；</li>
<li>NSKeyValueObservingOptionOld: 指示change字典中包含旧属性值；</li>
<li>NSKeyValueObservingOptionInitial: 相对复杂一些，NSKeyValueObserving.h文件中有详细说明，此处略过；</li>
<li>NSKeyValueObservingOptionPrior: 相对复杂一些，NSKeyValueObserving.h文件中有详细说明，此处略过；</li>
</ul>
</li>
<li><code>context</code>：需要传递给观察者的上下文信息</li>
</ul>
<p><font color="#008B8B"> 响应 </font>：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath</div><div class="line">                      ofObject:(<span class="keyword">id</span>)object</div><div class="line">                        change:(<span class="built_in">NSDictionary</span> *)change</div><div class="line">                       context:(<span class="keyword">void</span> *)context;</div></pre></td></tr></table></figure></p>
<ul>
<li><code>keyPath</code>：keyPath的类型是NSString，这导致了我们使用了错误的keyPath而不自知，譬如将<code>@&quot;contentSize&quot;</code>错误写成<code>@&quot;contentsize&quot;</code>，更好的方法是使用<code>NSStringFromSelector(SEL aSelector)</code>方法，即改为<code>NSStringFromSelector(@selector(contentSize))</code>.</li>
<li><code>object</code>：被观察者的对象</li>
<li><code>change</code>：根据上面的Options设置，给出对应的属性值</li>
<li><code>context</code>：使用 context 上下文以及其它辅助手段才能够帮助我们更加精准地确定被观测的对象。假如父类（ClassA）和子类（ClassB）都监听了同一个对象怎么办？是ClassB处理呢还是交给父类ClassA的<code>observeValueForKeyPath:ofObject:change:context:</code>处理呢？更复杂一点，如果子类的子类（设为ClassC）也监听了同一个对象，当ClassB接收到ClassC的<code>[super observeValueForKeyPath:keyPath ofObject:object change:change context:context]</code>消息时又该如何处理呢？<br>比较靠谱的做法是自己的屁股自己擦。ClassB的observe事务在ClassB中处理，怎么知道是自己的事务还是ClassC传上来的事务呢？用context参数判断！在add observer时为context参数设置一个独一无二的值即可，在responding处理时对这个context值进行检验。如此就解决了问题，但这需要靠用户（各个层级类的程序员用户）自觉遵守。</li>
</ul>
<p><font color="#008B8B"> 取消订阅 </font>：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)removeObserver:(<span class="built_in">NSObject</span> *)observer forKeyPath:(<span class="built_in">NSString</span> *)keyPath context:(<span class="keyword">void</span> *)context;</div><div class="line">- (<span class="keyword">void</span>)removeObserver:(<span class="built_in">NSObject</span> *)observer forKeyPath:(<span class="built_in">NSString</span> *)keyPath;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>注：使用KVO消息传递机制需要注意两点，①观察者必须知道被观察对象，即在同一作用域；②观察者还需要知道被观察对象的生命周期，因为在销毁发送者对象之前，需要取消观察者的注册。</p>
</blockquote>
<p>由于系统提供的API使用起来非常不优雅，使用过程也是非常麻烦需要注意很多问题：</p>
<ol>
<li>需要手动移除观察者，且移除观察者的时机必须合适；</li>
<li>注册观察者的代码和事件发生处的代码上下文不同，传递上下文是通过<code>void *</code>指针；</li>
<li>需要覆写<code>-observeValueForKeyPath:ofObject:change:context:</code>方法，比较麻烦；</li>
<li>在复杂的业务逻辑中，准确判断被观察者相对比较麻烦，有多个被观测的对象和属性时，需要在方法中写大量的 if 进行判断；</li>
</ol>
<p>如何优雅的解决呢？ - 使用 Facebook 开源的 <a href="">KVOController</a>，如下</p>
<h3 id="KVOController"><a href="#KVOController" class="headerlink" title="KVOController"></a>KVOController</h3><p><a href="https://github.com/facebook/KVOController" target="_blank" rel="external">KVOController</a>是Facebook开源的框架使用在iOS，maxOS上，是对Cocoa中KVO的封装。 提供了<code>block</code>和<code>@selector(SEL)</code>的回调操作，使用起来既简洁优雅又保证线程安全。相比原生KVO优点如下：</p>
<ol>
<li>不需要手动移除观察者；</li>
<li>实现 KVO 与事件发生处的代码上下文相同，不需要跨方法传参数；</li>
<li>使用 block 来替代方法能够减少使用的复杂度，提升使用 KVO 的体验；</li>
<li>每一个<code>keyPath</code>会对应一个属性，不需要在<code>block</code>中使用<code>if</code>判断<code>keyPath</code>（就像UIButton处理事件一样方便）；</li>
</ol>
<p>使用<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Model *model = [[Model alloc] init];</div><div class="line">model.name = <span class="string">@"snail-z"</span>;</div><div class="line"></div><div class="line"><span class="comment">// 初始化</span></div><div class="line"><span class="keyword">self</span>.fbKVO = [FBKVOController controllerWithObserver:<span class="keyword">self</span>];</div><div class="line"></div><div class="line"><span class="comment">// 注册监听并通过block方式直接获取</span></div><div class="line">[<span class="keyword">self</span>.fbKVO observe:model</div><div class="line">            keyPath:<span class="string">@"name"</span></div><div class="line">            options:<span class="built_in">NSKeyValueObservingOptionOld</span> | <span class="built_in">NSKeyValueObservingOptionNew</span></div><div class="line">              block:^(<span class="keyword">id</span> observer, <span class="keyword">id</span> object, <span class="built_in">NSDictionary</span> *change) &#123;</div><div class="line">    </div><div class="line">              <span class="built_in">NSLog</span>(<span class="string">@"change - %@"</span>,change[<span class="built_in">NSKeyValueChangeNewKey</span>]);</div><div class="line">&#125;];</div></pre></td></tr></table></figure></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 同时可以对model多个属性进行监听</span></div><div class="line">[<span class="keyword">self</span>.fbKVO observe:model</div><div class="line">         keyPaths:[<span class="built_in">NSArray</span> arrayWithObjects:<span class="string">@"name"</span>, <span class="string">@"age"</span>, <span class="literal">nil</span>]</div><div class="line">          options:<span class="built_in">NSKeyValueObservingOptionOld</span> | <span class="built_in">NSKeyValueObservingOptionNew</span></div><div class="line">            block:^(<span class="keyword">id</span> observer, <span class="keyword">id</span> object, <span class="built_in">NSDictionary</span> *change) &#123;</div><div class="line">    </div><div class="line">    		<span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,change);</div><div class="line">  &#125;];</div></pre></td></tr></table></figure>
<p>以上就是KVO的简单介绍和KVOController的使用。本文参考自<a href="http://draveness.me/kvocontroller/" target="_blank" rel="external">如何优雅地使用 KVO</a>，更多详细深入的内容请参考：☟</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="http://draveness.me/kvocontroller/" target="_blank" rel="external">如何优雅地使用 KVO</a></li>
<li><a href="http://zhangbuhuai.com/understanding-kvo/" target="_blank" rel="external">深入理解KVO</a></li>
<li><a href="http://www.cocoachina.com/industry/20140224/7866.html" target="_blank" rel="external">iOS KVC &amp; KVO</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Key-Value Observing，是iOS中的一种设计模式，用于检测对象的某些属性的实时变化情况并作出响应，这能够为我们在开发强交互、响应式应用以及实现视图和模型的双向绑定时提供大量的帮助。&lt;br&gt;KVO主要用于视图交互方面，比如界面的某些数据变化了，界面的显示也跟着需要变化，那就要建立数据和界面的关联。&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://note.snail-z.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="iOS" scheme="http://note.snail-z.me/tags/iOS/"/>
    
      <category term="Objective-C" scheme="http://note.snail-z.me/tags/Objective-C/"/>
    
      <category term="KVO" scheme="http://note.snail-z.me/tags/KVO/"/>
    
  </entry>
  
  <entry>
    <title>CADisplayLink学习笔记</title>
    <link href="http://note.snail-z.me/2017/03/17/CADisplayLink%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://note.snail-z.me/2017/03/17/CADisplayLink学习笔记/</id>
    <published>2017-03-17T14:21:32.000Z</published>
    <updated>2017-03-18T04:15:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>CADisplayLink相当于一个定时器，比起NSTimer，它可以确保系统渲染每一帧的时候我们的方法都被调用，从而保证了动画的流畅性。<br>iOS设备的屏幕刷新频率是固定的，CADisplayLink在正常情况下会在每次刷新结束都被调用，精确度相当高。NSTimer的精确度相对显得较低；CADisplayLink使用场合相对专一，适合做UI的不停重绘，比如自定义动画引擎或者视频播放的渲染。NSTimer的使用范围要广泛的多，各种需要单次或者循环定时处理的任务都可以使用。<br><a id="more"></a></p>
<h3 id="相关属性"><a href="#相关属性" class="headerlink" title="相关属性"></a>相关属性</h3><ol>
<li><code>preferredFramesPerSecond</code> （iOS10用这个方法）<br>标识每秒钟调用几次，比如每秒钟调用10次，那就是每0.1秒调用一次</li>
<li><code>frameInterval</code>（ios10被弃用）<br>标识间隔多少帧调用一次selector方法。<br>CADisplayLink的selector每秒调用次数 = 60 / frameInterval。<br>苹果文档中还提到：如果应用不能及时提供显示帧，则应该降低帧率，可以通过增大 frameInterval 这一属性的值来降低动画帧率。frameInterval 默认值为 1，表示每帧都回调一次selector。在没有卡顿时，iOS 设备屏幕显示每秒刷新60次，意味着 frameInterval 为默认值时，每秒回调60次 selector，当frameInterval 改为2时，每秒回调30（60/2）次 selector。</li>
<li><code>duration</code><br>只读的CFTimeInterval值，提供每帧之间的时间，也就是屏幕每次刷新的时间。</li>
<li><code>timestamp</code><br>只读的CFTimeInterval值，表示屏幕显示的上一帧的时间戳，这个属性通常被target用来计算下一帧中应该显示的内容。</li>
<li><code>paused</code><br>通过设置paused属性为YES可以暂停selector调用，默认值NO</li>
</ol>
<blockquote>
<p>注: CADisplayLink是不能被继承的</p>
</blockquote>
<h3 id="使用CADisplayLink"><a href="#使用CADisplayLink" class="headerlink" title="使用CADisplayLink"></a>使用CADisplayLink</h3><p>在应用中创建一个新的CADisplayLink 对象，把它添加到一个runloop中，并给他提供一个 target和select在屏幕刷新的时候调用。如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)startDisplayLink &#123;</div><div class="line">	<span class="keyword">if</span> (<span class="keyword">self</span>.displayLink == <span class="literal">nil</span>) &#123;  </div><div class="line">        <span class="keyword">self</span>.displayLink = [<span class="built_in">CADisplayLink</span> displayLinkWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(updateLayout)];  </div><div class="line">        [<span class="keyword">self</span>.displayLink addToRunLoop:[<span class="built_in">NSRunLoop</span> currentRunLoop] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];  </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)stopDisplayLink &#123;</div><div class="line">	<span class="comment">// 结束一个CADisplayLink，应该调用 - invalidate 从runloop中删除并删除之前绑定的 target跟selector</span></div><div class="line">	[<span class="keyword">self</span>.displayLink invalidate];</div><div class="line">	<span class="keyword">self</span>.displayLink = <span class="literal">nil</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">-(<span class="keyword">void</span>)updateLayout &#123;</div><div class="line">	<span class="comment">// do something</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>CADisplaylink 与 NSTimer 类似，都可以以一定的时间间隔触发回调 selector，不同点在于 CADisplaylink 的时间间隔是与屏幕的刷新频率相关联的，这一点决定了 CADisplaylink 的应用多与显示有关。</p>
</blockquote>
<h3 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h3><ul>
<li>当scrollview / tableview滚动时CADisplayLink停止响应。<br>要解决这个问题需要简单了解一下runloop的知识，runloop可以理解为cocoa下的一种消息循环机制，用来处理各种消息事件，我们在开发的时候并不需要手动去创建一个runloop，因为框架为我们创建了一个默认的runloop，通过[NSRunloop currentRunloop]可以得到一个当前线程下对应的runloop对象，不过需要注意的是不同的runloop之间消息的通知方式。在开启一个NSTimer或CADisplayLink实质上是在当前的runloop中注册了一个新的事件源，而当scrollView滚动的时候，当前的MainRunLoop是处于UITrackingRunLoopMode的模式下，在这个模式下是不会处理NSDefaultRunLoopMode的消息(因为RunLoop Mode不一样)，要想在scrollView滚动的同时也接受其它runloop的消息，就不能将Mode参数设置为NSDefaultRunLoopMode，而应该设置为NSRunLoopCommonModes。</li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="http://www.jianshu.com/p/c35a81c3b9eb" target="_blank" rel="external">CADisplayLink</a></li>
<li><a href="http://kittenyang.com/cadisplaylinkanduibezierpath/" target="_blank" rel="external">CADisplayLink结合UIBezierPath的神奇妙用</a></li>
<li><a href="http://tech.glowing.com/cn/usage-of-cadisplaylink/" target="_blank" rel="external">使用CADisplayLink实现果冻效果动画</a></li>
<li><a href="http://www.cnblogs.com/zhouxihi/p/6255669.html" target="_blank" rel="external">Objective-C三种定时器CADisplayLink / NSTimer / GCD的使用</a></li>
<li><a href="http://icetime17.github.io/2015/12/23/2015-12/iOS-%E4%BD%BF%E7%94%A8CADisplayLink%E6%9D%A5%E5%AE%9E%E7%8E%B0%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/" target="_blank" rel="external">iOS - 使用CADisplayLink来实现定时任务</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CADisplayLink相当于一个定时器，比起NSTimer，它可以确保系统渲染每一帧的时候我们的方法都被调用，从而保证了动画的流畅性。&lt;br&gt;iOS设备的屏幕刷新频率是固定的，CADisplayLink在正常情况下会在每次刷新结束都被调用，精确度相当高。NSTimer的精确度相对显得较低；CADisplayLink使用场合相对专一，适合做UI的不停重绘，比如自定义动画引擎或者视频播放的渲染。NSTimer的使用范围要广泛的多，各种需要单次或者循环定时处理的任务都可以使用。&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://note.snail-z.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="iOS" scheme="http://note.snail-z.me/tags/iOS/"/>
    
      <category term="Objective-C" scheme="http://note.snail-z.me/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>2017我在北京</title>
    <link href="http://note.snail-z.me/2017/03/16/2017%E6%88%91%E5%9C%A8%E5%8C%97%E4%BA%AC/"/>
    <id>http://note.snail-z.me/2017/03/16/2017我在北京/</id>
    <published>2017-03-15T16:18:53.000Z</published>
    <updated>2017-03-17T07:39:32.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="骑行"><a href="#骑行" class="headerlink" title="骑行"></a>骑行</h4><p>这是我们在北京的第一次骑行————永定河森林公园骑行。记得当年自己在上海骑车去看灰姑娘，电影结束后大雨滂沱，我没有王子，于是独自享受着在异乡的大雨中骑行，那时的我，那时的自行车，那时的伙伴，那时候的复旦，同济！我相信我还会继续在路上。<br><a id="more"></a></p>
<h4 id="藏身柳暗花明处"><a href="#藏身柳暗花明处" class="headerlink" title="藏身柳暗花明处"></a>藏身柳暗花明处</h4><p>来到北京后，我们在吵杂中用心感受这座城市，在它的怀抱中穿梭，有时候徒步，有时候骑行，有时候静静地坐在公交车上让眼睛悄悄地映着穿流的一切。玉渊潭的樱花，钓鱼台的银杏，香山的红叶，奥林匹克森林公园醉人的氧气！再怎么快节奏的生活，都会在这样的环境下慢下脚步，真心的想好好的过日子。</p>
<h4 id="逛京城"><a href="#逛京城" class="headerlink" title="逛京城"></a>逛京城</h4><p>西单，王府井，崇文门，国贸，三里屯，蓝色港湾，望京798，中关村，五道口，南锣鼓巷，雍和宫，簋街，立水桥，奥林匹克公园，故宫，长城等。我在这些地方留下了我的足迹。无论在哪里都离不开吃喝住行，在北京的吃喝住行还算是便利的，虽然南北有差异，但是在北京的生活并不让我排斥。</p>
<h4 id="谋生术"><a href="#谋生术" class="headerlink" title="谋生术"></a>谋生术</h4><p>工作就是做自己喜欢做的事情————敲代码。我喜欢做的事情很多，看书，画画，设计，总结一句就是看到美好的事物总是心生向往，想去触碰它。敲代码是一件我已经做了快4年的事情了。不是什么高手级别的，只是一年比一年对它更加熟悉，更加了解它，更想去了解它的点滴。对于想去了解它的动机也越来越单纯。它不再是一个用来挣钱养活自己的利器，而是它更加具有魅力，让我更想追寻着它奔跑。有人说追着累，而我有时候感觉看着它发展也挺高兴的。跟着它的脚步看它在未来某个时候蜕变或是变得消声觅迹也是一种心灵上的安慰。在这个互联网的时代，遍地是码农的时代，我只想做好自己，保持学习，分享的心态。</p>
<h4 id="流浪四海"><a href="#流浪四海" class="headerlink" title="流浪四海"></a>流浪四海</h4><p>曾经畅想过很多次我的老年生活————我希望到了某个年纪，有诗和远方。人总是喜欢用各种方式满足自己的好奇心。以前的生活很慢，慢得一生只够爱一个人。现在的生活很快，快到现在我在北京，晚上我估计已经在厦门和朋友聚餐了。这样的航空条件，还有当今的多媒体，让我们对整个国家乃至整个地球有了即视感。巴西的热带丛林，澳洲夏天的圣诞节，斯里兰卡的海岸线，欧洲的古老建筑，纽约的Open。我很想去亲身体验一下。想想这些场景，自己心里美滋滋的，脸上也洋溢的微笑，感觉棒棒的。这是我不敲代码想做的事情。(我会努力的带你走遍世界的每个角落~~)</p>
<p>— <a href="http://www.jianshu.com/p/17321419e238" target="_blank" rel="external">小鸿子的随笔</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;骑行&quot;&gt;&lt;a href=&quot;#骑行&quot; class=&quot;headerlink&quot; title=&quot;骑行&quot;&gt;&lt;/a&gt;骑行&lt;/h4&gt;&lt;p&gt;这是我们在北京的第一次骑行————永定河森林公园骑行。记得当年自己在上海骑车去看灰姑娘，电影结束后大雨滂沱，我没有王子，于是独自享受着在异乡的大雨中骑行，那时的我，那时的自行车，那时的伙伴，那时候的复旦，同济！我相信我还会继续在路上。&lt;br&gt;
    
    </summary>
    
      <category term="我和她" scheme="http://note.snail-z.me/categories/%E6%88%91%E5%92%8C%E5%A5%B9/"/>
    
    
      <category term="我和她" scheme="http://note.snail-z.me/tags/%E6%88%91%E5%92%8C%E5%A5%B9/"/>
    
  </entry>
  
  <entry>
    <title>Hexo静态博客使用笔记</title>
    <link href="http://note.snail-z.me/2017/03/15/Hexo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%AC%94%E8%AE%B0/"/>
    <id>http://note.snail-z.me/2017/03/15/Hexo静态博客搭建笔记/</id>
    <published>2017-03-15T14:59:29.000Z</published>
    <updated>2017-03-18T14:44:12.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://hexo.io" target="_blank" rel="external">Hexo</a> 是一个基于 <a href="https://nodejs.org/en/" target="_blank" rel="external">Node.js</a> 的静态博客程序，可以方便的生成静态网页托管在 <a href="https://github.com/" target="_blank" rel="external">GitHub</a> 和 <a href="https://www.heroku.com/" target="_blank" rel="external">Heroku</a> 上。作者是来自台湾的 <a href="https://github.com/hexojs/hexo" target="_blank" rel="external">tommy351</a>。<br>关于hexo静态网页搭建过程本文不再赘述，网上教程很多，本篇末尾也有相应的网络链接供参考。本文只是简单记录下使用hexo中的一些问题和需求更改。<br><a id="more"></a></p>
<h3 id="关联Github仓库"><a href="#关联Github仓库" class="headerlink" title="关联Github仓库:"></a>关联Github仓库:</h3><p>在hexo根目录下的 _config.yml 文件配置，末尾添加如下信息<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">deploy:</span></div><div class="line">  <span class="symbol">type:</span> git</div><div class="line">  <span class="symbol">repository:</span> <span class="comment"># 你的 GitHub 仓库地址，别忘了加上 .git （我的是https://github.com/snail-z/snail-z.github.io.git）</span></div><div class="line">  <span class="symbol">branch:</span> master</div></pre></td></tr></table></figure></p>
<p>注意，配置文件的冒号后必须有一个空格。deploy 下面的每个字段前必须空两个空格，严格要求。</p>
<p>然后执行命令：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">hexo generate <span class="comment"># 生成静态页面，可以简化为 hexo g</span></div><div class="line">hexo deploy   <span class="comment"># 部署到 GitHub，可以简化为 hexo d</span></div></pre></td></tr></table></figure></p>
<p>浏览器访问 <a href="https://snail-z.github.io" target="_blank" rel="external">snail-z.github.io</a> 就能看到自己的 Blog 了，如果看到 404 页面不要惊慌，一般延迟半分钟左右才能看到效果。耐心等待。</p>
<hr>
<h3 id="添加网页背景图"><a href="#添加网页背景图" class="headerlink" title="添加网页背景图"></a>添加网页背景图</h3><p>具体做法是在<code>hexo/themes/next/source/css/_custom/</code>里的custom.styl修改如下：<br> <figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">#header &#123;</div><div class="line">    background: url("../images/background-header.jpg");</div><div class="line">    background-size: cover;</div><div class="line">&#125;</div><div class="line">body &#123;</div><div class="line">    background: url("../images/background-body.jpg");</div><div class="line">    background-size: cover;</div><div class="line">&#125;</div><div class="line">#footer &#123;</div><div class="line">    background: url("../images/background-footer.jpg");</div><div class="line">    background-size: cover;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p> 将上述中的图片放到<code>hexo/themes/next/source/images</code>中即可。</p>
<hr>
<h3 id="创建标签云页面和分类页面"><a href="#创建标签云页面和分类页面" class="headerlink" title="创建标签云页面和分类页面"></a>创建标签云页面和分类页面</h3><ul>
<li>添加标签云页面，并在menu中显示。</li>
</ul>
<ol>
<li><p>新建一个页面，命名为 tags 。命令如下</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo new page <span class="string">"tags"</span></div></pre></td></tr></table></figure>
</li>
<li><p>编辑刚新建的页面，在<code>hexo/source/tags</code>下的index.md文件中，将页面的类型设置为 tags ，主题将自动为这个页面显示标签云。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#title: All tags # 一般省略标题</span></div><div class="line"><span class="symbol">date:</span> <span class="number">2017</span>-<span class="number">3</span>-<span class="number">17</span> <span class="number">9</span><span class="symbol">:</span><span class="number">21</span><span class="symbol">:</span><span class="number">20</span></div><div class="line"><span class="symbol">type:</span> <span class="string">"tags"</span></div><div class="line"><span class="symbol">comments:</span> <span class="literal">false</span> <span class="comment"># 如果有启用多说评论，默认页面也会带有评论。需要关闭的话，添加字段comments设为false</span></div></pre></td></tr></table></figure>
</li>
<li><p>设置menu。编辑主题的_config.yml，添加tags到menu中，如下:</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">menu:</span></div><div class="line">  <span class="symbol">home:</span> /</div><div class="line">  <span class="symbol">archives:</span> /archives</div><div class="line">  <span class="symbol">tags:</span> /tags</div></pre></td></tr></table></figure>
</li>
<li><p>写文章时添加对应标签，例如本篇：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">title:</span> Hexo静态博客使用笔记</div><div class="line"><span class="symbol">date:</span> <span class="number">2017</span>-<span class="number">03</span>-<span class="number">15</span> <span class="number">22</span><span class="symbol">:</span><span class="number">59</span><span class="symbol">:</span><span class="number">29</span></div><div class="line"><span class="symbol">categories:</span>               <span class="comment"># 文章分类目录，可省略</span></div><div class="line">    - 技术</div><div class="line"><span class="symbol">tags:</span> Hexo</div><div class="line">---</div></pre></td></tr></table></figure>
<p>以上云标签就创建成功了，可以运行查看效果了。</p>
</li>
</ol>
<ul>
<li>添加分类页面</li>
</ul>
<ol>
<li><p>步骤与添加tags类似，首先新建一个页面，命名为 categories，如下：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo new page <span class="string">"categories"</span></div></pre></td></tr></table></figure>
</li>
<li><p>同样编辑刚新建的页面，将页面的类型设置为 categories ，主题将自动为这个页面显示所有分类。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">date:</span> <span class="number">2017</span>-<span class="number">03</span>-<span class="number">17</span> 09<span class="symbol">:</span><span class="number">25</span><span class="symbol">:</span><span class="number">20</span></div><div class="line"><span class="symbol">type:</span> <span class="string">"categories"</span></div><div class="line"><span class="symbol">comments:</span> <span class="literal">false</span></div></pre></td></tr></table></figure>
</li>
<li><p>在菜单中添加链接。编辑主题的 _config.yml ，将 menu 中的 categories: /categories 注释去掉，如下:</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">menu:</span></div><div class="line">  <span class="symbol">home:</span> /</div><div class="line">  <span class="symbol">categories:</span> /categories</div><div class="line">  <span class="symbol">archives:</span> /archives</div><div class="line">  <span class="symbol">tags:</span> /tags</div></pre></td></tr></table></figure>
<p>以上分类页面就创建成功了，打开博客查看效果吧。</p>
</li>
</ol>
<hr>
<h3 id="其它设置"><a href="#其它设置" class="headerlink" title="其它设置"></a>其它设置</h3><ul>
<li>单独修改文章字体颜色，在<code>hexo/themes/next/source/css/_variables/</code>下的<code>base.styl</code>文件中，定位到<code>$text-color = red</code>处，这样就将字体修改成了红色。默认#555</li>
<li>修改subtitle颜色，在<code>hexo/themes/next/source/css/_variables/</code>下的<code>base.styl</code>中定位到<code>$subtitle-color = red</code>，这改成了红色。默认#555</li>
<li>在主题配置 - NexT使用文档中提及了如何设置字体样式，这里就不再赘述了。如果想自定义字体大小以及颜色，可以直接在Markdown 文档编辑中使用<code>html</code>语法<br><code>&lt;font size=4 &gt; 这里输入文字，自定义大小 &lt;/font&gt;</code><br><code>&lt;font color=&quot;#FF0000&quot;&gt; 这里输入文字，自定义颜色的字体 &lt;/font&gt;</code></li>
</ul>
<hr>
<h3 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h3><ul>
<li><a href="https://note.leodev.me/2016/09/01/Hexo-3-1-1-Staic-Blog-Build-Guide/" target="_blank" rel="external">Hexo 3.1.1 静态博客搭建指南</a></li>
<li><a href="http://baixin.io/2015/08/HEXO搭建个人博客/" target="_blank" rel="external">HEXO搭建个人博客</a></li>
<li><a href="http://ibruce.info/2013/11/22/hexo-your-blog/" target="_blank" rel="external">hexo你的博客</a></li>
<li><a href="http://oakland.github.io/2016/04/30/hexo-%E5%A6%82%E4%BD%95%E6%9B%B4%E6%8D%A2%E4%B8%BB%E9%A2%98%E3%80%81%E5%88%A0%E9%99%A4%E6%96%87%E7%AB%A0/" target="_blank" rel="external">hexo如何更换主题、删除文章</a></li>
<li><a href="https://www.zybuluo.com/mdeditor" target="_blank" rel="external">Markdown 使用</a></li>
<li><a href="http://www.yaosansi.com/post/markdown-on-github/" target="_blank" rel="external">GitHub上Markdown基本使用</a></li>
<li><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="external">Hexo 使用文档</a></li>
<li><a href="http://theme-next.iissnan.com" target="_blank" rel="external">NexT 使用文档</a></li>
<li><a href="http://zhouhuix.cn/2016/11/24/%E4%BF%AE%E6%94%B9Hexo%E7%9A%84Next%E4%B8%BB%E9%A2%98/" target="_blank" rel="external">修改Hexo的Next主题</a></li>
<li><a href="https://www.fengyu.info/blog/2016/06/30/hexo-theme-next-modify/" target="_blank" rel="external">Hexo Next主题修改与优化 – 基础篇</a></li>
<li><a href="http://www.wuxubj.cn/2016/08/Hexo-nexT-build-personal-blog/" target="_blank" rel="external">Hexo+nexT主题搭建个人博客</a></li>
<li><a href="https://github.com/iissnan/hexo-theme-next/wiki" target="_blank" rel="external">hexo-theme-next wiki</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://hexo.io&quot;&gt;Hexo&lt;/a&gt; 是一个基于 &lt;a href=&quot;https://nodejs.org/en/&quot;&gt;Node.js&lt;/a&gt; 的静态博客程序，可以方便的生成静态网页托管在 &lt;a href=&quot;https://github.com/&quot;&gt;GitHub&lt;/a&gt; 和 &lt;a href=&quot;https://www.heroku.com/&quot;&gt;Heroku&lt;/a&gt; 上。作者是来自台湾的 &lt;a href=&quot;https://github.com/hexojs/hexo&quot;&gt;tommy351&lt;/a&gt;。&lt;br&gt;关于hexo静态网页搭建过程本文不再赘述，网上教程很多，本篇末尾也有相应的网络链接供参考。本文只是简单记录下使用hexo中的一些问题和需求更改。&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://note.snail-z.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Hexo" scheme="http://note.snail-z.me/tags/Hexo/"/>
    
  </entry>
  
</feed>
